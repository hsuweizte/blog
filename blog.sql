CREATE DATABASE  IF NOT EXISTS `blog` /*!40100 DEFAULT CHARACTER SET utf8mb3 COLLATE utf8mb3_unicode_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `blog`;
-- MySQL dump 10.13  Distrib 8.0.32, for Win64 (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	8.0.32

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `t_blog`
--

DROP TABLE IF EXISTS `t_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `appreciation` bit(1) NOT NULL,
  `content` longtext CHARACTER SET utf8mb3 COLLATE utf8mb3_bin NOT NULL,
  `commentabled` bit(1) NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `first_picture` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `flag` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommend` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `views` int DEFAULT NULL,
  `type_id` bigint DEFAULT NULL,
  `user_id` bigint DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`),
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`),
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`),
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog`
--

LOCK TABLES `t_blog` WRITE;
/*!40000 ALTER TABLE `t_blog` DISABLE KEYS */;
INSERT INTO `t_blog` VALUES (6,_binary '\0','**1、JavaScript 有六種資料類型：**\r\n\r\n-  數值（number）：整數和小數（比如1和3.14）\r\n-  字串（string）：字元組成的文本（比如”Hello World”）\r\n-  布林值（boolean）：`true`（真）和`false`（假）兩個特定值\r\n-  `undefined`：表示“未定義”或不存在，即由於目前沒有定義，所以此處暫時沒有任何值\r\n-  `null`：表示無值，即此處的值就是“無”的狀態。\r\n-  物件（object）：各種值組成的集合\r\n\r\n**2、六種整體上分為兩類：**\r\n\r\n-  原始類型（基底資料型別）\r\n\r\n   -  數值\r\n   -  字串\r\n   -  布林值\r\n\r\n-  合成類型\r\n\r\n   -  物件\r\n\r\n   >  物件通常有多個原始類型的值合成，像一個存放各種值的容器。\r\n\r\n   \r\n\r\n**3、物件分為三個子類型：**\r\n\r\n-  狹義的物件（object）\r\n-  陣列（array）\r\n-  函數（function）\r\n   -  作為一種資料類型，可以進行賦值和傳遞\r\n   -  帶來了程式設計的靈活性\r\n   -  體現 JavaScript 的函數式語言的本質\r\n\r\n>  注意：JavaScript 的所有資料類型，都可以視為廣義的物件。原始類型的資料也可以用物件方式調用。\r\n\r\n\r\n\r\n**4、`undefined` 和 `null` 是兩個特殊的值**\r\n\r\n\r\n\r\n## 2. typeof 運算子\r\n\r\nJavaScript 有三種方法判斷一個值是什麼類型：\r\n\r\n-  `typeof` 運算子\r\n-  `instanceof`運算子\r\n-  `Object.prototype.toString` 方法\r\n\r\n**typeof 運算子返回一個值的資料類型：**\r\n\r\n（1）原始類型：\r\n\r\n```javascript\r\ntypeof 2342 //\"number\"\r\ntypeof \'2342\' //\"string\"\r\ntypeof false // \"boolean\"\r\n```\r\n\r\n（2）函數\r\n\r\n```javascript\r\nfunction fun() {}\r\ntypeof fun\r\n//\"function\"\r\n```\r\n\r\n（3）undefined\r\n\r\n```javascript\r\ntypeof undefined\r\n// \"undefined\"\r\n```\r\n\r\n檢查一個未聲明的變數，而不報錯\r\n\r\n```javascript\r\na\r\n// ReferenceError: a is not defined\r\ntypeof a \r\n// \"undefined\"\r\n```\r\n\r\n實際通常運用在判斷語句：\r\n\r\n```javascript\r\n//錯誤的寫法\r\nif (a) {\r\n    //...\r\n}\r\n// ReferenceError: a is not defined\r\n\r\n//正確的寫法\r\nif (typeof a === \"undefined\") {\r\n    //...\r\n}\r\n```\r\n\r\n（4）其他\r\n\r\n其他情況都返回 `object`\r\n\r\n```javascript\r\ntypeof window // \"object\"\r\ntypeof {} // \"object\"\r\ntypeof [] // \"object\"\r\ntypeof null // \"object\"\r\n```\r\n\r\n\r\n\r\n## 3. null 和 undefined\r\n\r\n\r\n\r\n### 3.1 概述\r\n\r\n-  `null` 和 `undefined`都表示沒有的意思，語法效果幾乎沒區別\r\n\r\n```javascript\r\nvar a = undefined;\r\n//或者\r\nvar a = null;\r\n```\r\n\r\n`null`和 `undefined` 在`if`語句中，被自動轉換為 `false`\r\n\r\n```javascript\r\nif (!undefined) {\r\n    console.log(\'undefined is false\');\r\n}\r\n// undefined is false;\r\nif (!null) {\r\n    console.log(\'null is false\');\r\n}\r\n// null is false\r\n\r\nundefined == null\r\n// true\r\n```\r\n\r\n`null`轉換為數值時為`0`\r\n\r\n```javascript\r\nNumber(null) //0\r\n6 + null // 6\r\n```\r\n\r\n`undefined` 轉換為數值時為 `NaN`\r\n\r\n```javascript\r\nNumber(undefined) // NaN\r\n6 + undefined // NaN\r\n```\r\n\r\nJavaScript 中 `null`包含在物件（object）類型中\r\n\r\n```javascript\r\ntypeof null // \"object\"\r\n```\r\n\r\n\r\n\r\n### 3.2 用法和含義\r\n\r\n`null`表示空值，即該處的值現在為空。調用函數時，某個參數未設置任何值，這時就可以傳入`null`。\r\n\r\n`undefined` 表示 “未定義”\r\n\r\n```javascript\r\n//變數聲明了，但沒有賦值\r\nvar i;\r\ni // undefined\r\n\r\n//調用函數時，應該提供的參數沒有提供，該參數等於 undefined\r\nfunction f(x) {\r\n    return x;\r\n} \r\nf() // undefined\r\n\r\n// 物件沒有賦值的屬性\r\nvar o = new Object();\r\no.p // undefined\r\n\r\n// 函數沒有返回值時，默認返回 undefined\r\nfunction f() {}\r\nf() // undefined\r\n```\r\n\r\n\r\n\r\n## 4. 布林值\r\n\r\n布林值代表真（true）和假（false）的兩個狀態。只有這兩個值。\r\n\r\n下列運算子返回布林值：\r\n\r\n-  兩元運算子： `&&` (And)，`||`（Or）\r\n-  前置邏輯運算子：`!` （Not）\r\n-  相等運算子： `===`， `!==`，`==`， `!=`\r\n-  比較運算子：`>`，`>=`，`<`，`<=`\r\n\r\n如果JavaScript預期某個位置應該是布林值，會將該位置上現有的值自動轉為布林值。\r\n\r\n轉換規則除了下面六個值被轉換為 `false`，其他值都視為 `true`\r\n\r\n-  `undefined`\r\n-  `null`\r\n-  `false`\r\n-  `0`\r\n-  `NaN`\r\n-  `\"\"`或`\'\'`（空字串）\r\n\r\n布林值往往用於程式流程的控制\r\n\r\n```javascript\r\nif (\'\') {\r\n  console.log(true);\r\n}\r\n// 沒有任何輸出\r\n```\r\n\r\n特別注意的是，空陣列（`[]`）和空物件（`{}`）對應的布林值，都是`true`\r\n\r\n```javascript\r\nif ([]) {\r\n  console.log(true);\r\n}\r\n// true\r\n\r\nif ({}) {\r\n  console.log(true);\r\n}\r\n// true\r\n```\r\n\r\n',_binary '\0','2022-10-21 20:40:10','https://unsplash.it/800/600?1','翻譯',_binary '',_binary '',_binary '\0','數據類型','2023-05-13 23:43:08',16,8,1,'JavaScript 有六種資料類型：數值（number）：整數和小數（比如1和3.14）字串（string）：字元組成的文本（比如”Hello World”）布林值（boolean）：true（真）和false（假）兩個特定值、undefined：表示“未定義”或不存在，即由於目前沒有定義，所以此處暫時沒有任何值'),(7,_binary '','## 1. 語句\r\n\r\n-  **一個語句**\r\n\r\n```javascript\r\nvar a = 1 + 3;\r\n```\r\n\r\n-  **兩個語句在一行**\r\n\r\n```javascript\r\nvar a = 1 + 3 ; var b = \'abc\';\r\n```\r\n\r\n-  **三個空語句**\r\n\r\n```\r\n;;;\r\n```\r\n\r\n-  **無意義語句，運算式不需要分號結尾。**\r\n\r\n```javascript\r\n1 + 3;\r\n\'abc\';\r\n```\r\n\r\n\r\n\r\n## 2. 變數\r\n\r\n### 2. 1 基本概念\r\n\r\n-  **變數是對“值”的引用，使用變數等同於引用一個值。每個變數都有一個變數名。**\r\n\r\n```javascript\r\nvar a = 1;//數值1“賦值”給變數a\r\n```\r\n\r\n>  先聲明變數 a ， 然後建立 a 與 1 的引用關係。var是變數聲明，它通知解釋引擎創建一個變數 a\r\n\r\n\r\n\r\n-  **變數的聲明和賦值，是分開的兩個步驟。上面是合成在一起。**\r\n\r\n```javascript\r\nvar a;//聲明變數 a，\r\na = 1;//數值 1 “賦值”給變數 a\r\n```\r\n\r\n\r\n\r\n-  **變數沒有賦值，則該變數的值是 `undefined`**\r\n\r\n   >  `undefined` 是 JavaScript 的關鍵字，表示“無定義”\r\n',_binary '','2022-10-21 20:40:06','https://unsplash.it/800/600?2','翻譯',_binary '',_binary '',_binary '','基本語法','2023-05-14 19:47:48',2,8,1,'變數是對“值”的引用，使用變數等同於引用一個值。每個變數都有一個變數名。變數的聲明和賦值，是分開的兩個步驟。上面是合成在一起。變數沒有賦值，則該變數的值是 undefined'),(8,_binary '','## 1. 什麼是 JavaScript 語言？\r\n\r\n-  **羽量級的指令碼語言**，不具備開發作業系統的能力，只用來編寫控制其他大型應用程式的\"腳本\"。\r\n-  **嵌入式語言**，依賴宿主環境\r\n-  **物件模型語言**\r\n-  **核心語法精簡**\r\n   -  基本語法構造（操作符、控制結構、語句）\r\n   -  標準庫（Arry、Date、Math等）\r\n-  **宿主環境**\r\n   -  流覽器\r\n      -  流覽器控制類：操作流覽器\r\n      -  DOM 類：操作網頁的各種元素\r\n      -  Web 類：實現互聯網的各種功能\r\n   -  伺服器（Node）\r\n\r\n### 2. 為什麼學習 JavaScript？\r\n\r\n-  適合作為學習程式設計的入門語言\r\n-  適合當作日常開發的工作語言\r\n-  前途最光明的電腦語言之一\r\n\r\n#### 2.1 操作流覽器的能力\r\n\r\n-  為開發者提供操作流覽器的能力，讓網頁提供各種特效，提供良好互動體驗。\r\n-  幾乎所有網頁都是用 JavaScript。\r\n-  互聯網開發者的利器。\r\n\r\n#### 2.2 廣泛的使用領域\r\n\r\n**（1）流覽器的平臺化**\r\n\r\nJavaScript可以做更多的事情（操作本地檔、圖片、調用攝像頭等等）\r\n\r\n**（2）Node**\r\n\r\nNode 專案使 JavaScript 可用於開發伺服器端大型專案，前後端都使用 JavaScript  開發成為現實。\r\n\r\n**（3）資料庫操作**\r\n\r\n大部分的 NoSQL 支援 JavaScript 直接操作。基於 SQL 語言的開來源資料庫 PostgreSQL 支援 JavaScript 作為操作語言，可以部分取代 SQL 查詢語言。\r\n\r\n**（4）跨移動平臺**\r\n\r\nPhoneGap 專案將 JavaScript 和 HTML5 打包在一個容器中，使它能同時在 iOS 和安卓上運行。React Native 可以讓開發者使用 JavaScript 開發原生 iOS 和安卓的APP。\r\n\r\n手機作業系統 Firefox OS 直接將 JavaScript 作為作業系統的平臺語言。\r\n\r\n**（5）內嵌指令碼語言**\r\n\r\n越來越多的應用程式，將 JavaScript 作為內嵌的指令碼語言，例如 Adobe 公司的 PDF 閱讀器 Acrobat、Linux 桌面環境 GNOME 3\r\n\r\n**（6）跨平臺的桌面應用程式**\r\n\r\nChromium OS、Windows 8 等作業系統直接支援 JavaScript 編寫應用程式。Mozilla 的 Open Web Apps 項目、Google 的 [Chrome App 項目](http://developer.chrome.com/apps/about_apps)、Github 的 [Electron 項目](http://electron.atom.io/)、以及 [TideSDK 項目](http://tidesdk.multipart.net/docs/user-dev/generated/)，都可以用來編寫運行於 Windows、Mac OS 和 Android 等多個桌面平臺的程式，不依賴流覽器。\r\n\r\n**（7）小結**\r\n\r\n只用 JavaScript 一種語言，就可以開發出不同平臺（桌面端、伺服器端、手機端）的程式。\r\n\r\nJavaScript 是 GitHub 上使用量排名第一的語言。\r\n\r\n [“Atwood 定律”](http://www.codinghorror.com/blog/2007/07/the-principle-of-least-power.html)：\r\n\r\n>  “所有可以用 JavaScript 編寫的程式，最終都會出現 JavaScript 的版本。”(Any application that can be written in JavaScript will eventually be written in JavaScript.)\r\n\r\n#### 2.3 易學性\r\n\r\n**（1）學習環境無處不在**\r\n\r\n只要有流覽器就能運行 JavaScript 程式；只要有文字編輯器，就能編寫 JavaScript 程式。不用安裝複雜的IDE（整合式開發環境）和編譯器。\r\n\r\n**（2）簡單性**\r\n\r\n與其他指令碼語言（如 Python 或者 Ruby），JavaScript 語法相對簡單，本身的語法特性不多。而且語法中的複雜部分，也不是必須要學會。完全可以用簡單名利，完成大部分的操作。\r\n\r\n**（3）與主流語言的相似性**\r\n\r\nJavaScript語法很類似 C/C++ 和 Java，如果有學過這些語言，JavaScript的入門會非常容易。\r\n\r\nJavaScript 的複雜性：\r\n\r\n-  大量的外部 API。數量龐大，難以掌握\r\n-  有一些設計缺陷。某些地方設計不合理，學習 JavaScript，很大一部分時間用來搞清楚哪些地方有陷阱。\r\n\r\n#### 2.4 強大的性能\r\n\r\nJavaScript 的性能優勢體現在以下方面。\r\n\r\n**（1）靈活的語法，表達力強**\r\n\r\n-  過程式程式設計\r\n-  函數式程式設計\r\n-  寫併發處理\r\n-  非同步程式設計\r\n\r\n**（2）支援編譯運行**\r\n\r\n-  編譯後運行，程式高度優化\r\n-  效率接近二級制程式\r\n-  JavaScript 引擎的快速發展，性能越來越好\r\n\r\n**（3）事件驅動和非阻塞式設計**\r\n\r\n-  事件驅動（event-driven）\r\n-  非阻塞式（non-blocking）\r\n-  適合高併發環境\r\n-  普通硬體可以承受很大的訪問量\r\n\r\n#### 2.5 開放性\r\n\r\n-  開放的語言\r\n-  IOS 國際標準\r\n-  不存在版權和專利問題\r\n\r\n#### 2.6 社區支持和就業機會\r\n\r\n-  極大的社區，全世界的程式師都在使用 JavaScript\r\n-  廣泛的文獻圖書和豐富的代碼資源\r\n-  豐富的開源函式程式庫可供選擇。\r\n\r\n\r\n-  數量眾多的 JavaScript 程式師，好招聘\r\n-  開發者好找一份 JavaScript 的工作\r\n\r\n### 3. 實驗環境\r\n\r\n只要打開 Chrome 流覽器的“開發者工具”（Developer Tools），就可以在它的“控制台”（console）運行 JavaScript 代碼。\r\n\r\n進入“控制台”，有兩種方法。\r\n\r\n>  -  快速鍵。在 Chrome 流覽器中，直接按`Option + Command + J`（Mac）或者`Ctrl + Shift + J`（Windows / Linux）。\r\n>  -  菜單。從“工具”（Tools）功能表中打開“開發者工具”，然後點擊 Console 選項卡。“開發者工具”的快速鍵是 F12，或者`Option + Command + I`（Mac）以及`Ctrl + Shift + I`（Windows / Linux）。\r\n\r\n進入控制台以後，就可以在提示符後輸入代碼，然後按`Enter`鍵，代碼就會執行。如果按`Shift + Enter`鍵，就是代碼換行，不會觸發執行。建議閱讀本教程時，將代碼複製到控制台進行實驗。\r\n\r\n將下面的程式複製到“控制台”，按下回車後，就可以看到運行結果。\r\n\r\n```js\r\nfunction greetMe(yourName) {\r\n  console.log(\'Hello \' + yourName);\r\n}\r\n\r\ngreetMe(\'World\')\r\n// Hello World\r\n```\r\n',_binary '','2022-10-21 17:13:34','https://unsplash.it/800/600?3','原創',_binary '',_binary '',_binary '','JavaScript標準教學提綱','2023-05-14 19:46:33',1,8,1,'羽量級的指令碼語言，不具備開發作業系統的能力，只用來編寫控制其他大型應用程式的”腳本”。嵌入式語言，依賴宿主環境、物件模型語言、核心語法精簡'),(9,_binary '','## 1.概述\r\n\r\n### 1.1 整數和浮點數\r\n\r\n-  JavaScript內部所有數位以 64 位元浮點數形式存儲。所以 `1 = 1.0`\r\n\r\n```javascript\r\n1 === 1.0 //true\r\n```\r\n\r\n```javascript\r\n0.1 + 0.2 === 0.3\r\n// false\r\n\r\n0.3 / 0.1\r\n// 2.9999999999999996\r\n\r\n(0.3 - 0.2) === (0.2 - 0.1)\r\n// false\r\n```\r\n\r\n\r\n\r\n## 1.2 數值精度\r\n\r\n-  JavaScript 浮點數的64個二進位位元\r\n\r\n```javascript\r\n(-1)^符號位元 * 1.xx...xx * 2^指數位\r\n```\r\n\r\n-  精度最多只能到53個二進位位元，絕對值小於2的53次方的整數，即-(253-1)到253-1\r\n\r\n```javascript\r\nMath.pow(2, 53)\r\n// 9007199254740992\r\n\r\nMath.pow(2, 53) + 1\r\n// 9007199254740992\r\n\r\nMath.pow(2, 53) + 2\r\n// 9007199254740994\r\n\r\nMath.pow(2, 53) + 3\r\n// 9007199254740996\r\n\r\nMath.pow(2, 53) + 4\r\n// 9007199254740996\r\n```\r\n\r\n>  大於等於2的53次方的數值，都無法保持精度\r\n\r\n```javascript\r\nMath.pow(2, 53)\r\n// 9007199254740992\r\n\r\n// 多出的三個有效數字，將無法保存\r\n9007199254740992111\r\n// 9007199254740992000\r\n```\r\n\r\n\r\n\r\n## 1.3 數值範圍\r\n\r\n-  JavaScript 能夠表示的數值範圍為2的1024方到2的-1023方（開區間），超出這個範圍的數無法表示\r\n-  如果指數部分等於或超過最大正值1024，JavaScript 會返回`Infinity`這稱為“正向溢出”；\r\n-  如果等於或超過最小負值-1023（即非常接近0），JavaScript 會直接把這個數轉為0，這稱為“負向溢出”。\r\n\r\n```javascript\r\nvar x = 0.5;\r\n\r\nfor(var i = 0; i < 25; i++) {\r\n  x = x * x;\r\n}\r\n\r\nx // 0\r\n```\r\n\r\n>  由於最後結果太接近0，超出了可表示的範圍，JavaScript 就直接將其轉為0\r\n\r\n-  具體的最大值和最小值\r\n\r\n```javascript\r\nNumber.MAX_VALUE // 1.7976931348623157e+308\r\nNumber.MIN_VALUE // 5e-324\r\n```\r\n\r\n## 2.數值的標記法\r\n\r\n-  科學計數法表示數值\r\n\r\n```javascript\r\n123e3 //123000\r\n123e-3 //0.123\r\n-3.1E+12\r\n.1e-23\r\n```\r\n\r\n>  字母`e`或`E`的後面，跟著一個整數，表示這個數值的指數部分。\r\n\r\n-  JavaScript 自動轉換數值為科學計數情況\r\n\r\n（1） 小數點前的數字多於 21 位元\r\n\r\n```javascript\r\n1234567890123456789012\r\n//1.2345678901234568e+21\r\n123456789012345678901\r\n// 123456789012345680000\r\n```\r\n\r\n（2）小數點後的零多於5位\r\n\r\n```javascript\r\n// 小數點後緊跟5個以上的零，\r\n// 就自動轉為科學計數法\r\n0.0000003 // 3e-7\r\n\r\n// 否則，就保持原來的字面形式\r\n0.000003 // 0.000003\r\n```\r\n\r\n\r\n\r\n## 3. 數值的進制\r\n\r\n-  JavaScript 對整數有四種進制的表示方法\r\n   -  十進位：沒有前導0的數值\r\n   -  八進制：有首碼 0o 或 0O 的數值，或者有前導0、且只有用到 0-7的八個阿拉伯數字的數值\r\n   -  十六進位：有首碼 0x 或 0X 的數值\r\n   -  二進位：有首碼 0b 或者 0B 的數值\r\n-  JavaScript 自動將八進制、十六進位、二進位轉換十進位\r\n\r\n```javascript\r\n0xff // 255\r\n0o377 // 255\r\n0b11 // 3\r\n```\r\n\r\n-  如果八進制、十六進位、二進位的數值裡面，出現不屬於該進制的數字，就會報錯\r\n\r\n```javascript\r\n0xzz // 報錯\r\n0o88 // 報錯\r\n0b22 // 報錯\r\n```\r\n\r\n>  上面代碼中，十六進位出現了字母`z`、八進制出現數位`8`、二進位出現數位`2`，因此報錯\r\n\r\n通常來說，有前導0的數值會被視為八進制，但是如果前導0後面有數字`8`和`9`，則該數值被視為十進位。\r\n\r\n```javascript\r\n0888 // 888\r\n0777 // 511\r\n```\r\n\r\n>  前導0表示八進制，處理時很容易造成混亂。ES5的嚴格模式和ES6，已經廢除了這種標記法，但是流覽器目前還支持。\r\n\r\n\r\n\r\n## 4. 特殊數值\r\n\r\nJavaScript 提供幾個特殊的數值\r\n\r\n### 4.1 整零和負零\r\n\r\n-  JavaScript 中任何一個數都有一個對應的負值，`0`也不例外。\r\n\r\n```javascript\r\n-0 === +0 // true\r\n0 === -0 // true\r\n0 === +0 // true\r\n```\r\n\r\n-  幾乎所有場合，正零和負零都會被當作正常的`0`\r\n\r\n```javascript\r\n+0 // 0\r\n-0 // 0\r\n(-0).toString() // \'0\'\r\n(+0).toString() // \'0\'\r\n```\r\n\r\n-  `+0`或`-0`當作分母，返回的值是不相等的\r\n\r\n```javascript\r\n(1 / +0) === (1 / -0) // false\r\n```\r\n\r\n>  除以正零得到`+Infinity`，除以負零得到`-Infinity` , 這兩者不相等\r\n\r\n\r\n\r\n### 4.2 NaN\r\n\r\n**（1）含義**\r\n\r\n-  表示 ”非數位“ ，主要出現在字串解析成數位出錯的場合。\r\n\r\n```javascript\r\n5 - \'x\' // NaN\r\n```\r\n\r\n>  代碼運行時，會自動將字串`x`轉為數值，但是由於`x`不是數值，所以最後得到結果為`NaN`，表示它是“非數字”（`NaN`）\r\n\r\n-  一些數學函數的運算結果會出現`NaN`。\r\n\r\n```javascript\r\nMath.acos(2) // NaN\r\nMath.log(-1) // NaN\r\nMath.sqrt(-1) // NaN\r\n```\r\n\r\n-  `0`除以`0`也會得到`NaN`。\r\n\r\n```javascript\r\n0 / 0 // NaN\r\n```\r\n\r\n-  `NaN`不是一種獨立的資料類型, 而是一種特殊的數值，其資料類型依然為 `Number`\r\n\r\n```javascript\r\ntypeof NaN // \'number\'\r\n```\r\n\r\n\r\n\r\n**（2）運算規則**\r\n\r\n-  `NaN`不等於任何值，包括它本身。\r\n\r\n```javascript\r\nNaN === NaN // false\r\n```\r\n\r\n-  陣列的`indexOf` 方法對 `NaN` 不成立\r\n\r\n```javascript\r\n[NaN].indexOf(NaN) // -1\r\n```\r\n\r\n-  `NaN`在布耳運算時被當作`false`。\r\n\r\n```javascript\r\nBoolean(NaN) // false\r\n```\r\n\r\n-  `NaN`與任何數（包括它自己）的運算，得到的都是`NaN`。\r\n\r\n```javascript\r\nNaN + 32 // NaN\r\nNaN - 32 // NaN\r\nNaN * 32 // NaN\r\nNaN / 32 // NaN\r\n```\r\n\r\n\r\n\r\n**（3）判斷 NaN 的方法**\r\n\r\n-  `isNaN`方法可以用來判斷一個值是否為`NaN`。\r\n\r\n```javascript\r\nisNaN(NaN) // true\r\nisNaN(123) // false\r\n```\r\n\r\n>  `isNaN`只對數值有效，如果傳入其他值，會被先轉成數值。比如，傳入字串的時候，字串會被先轉成`NaN`，所以最後返回`true`，這一點要特別引起注意。也就是說，`isNaN`為`true`的值，有可能不是`NaN`，而是一個字串。\r\n\r\n```javascript\r\nisNaN(\'Hello\') // true\r\n// 相當於\r\nisNaN(Number(\'Hello\')) // true\r\n```\r\n\r\n-  對於物件和陣列，`isNaN`也返回`true`。\r\n\r\n```javascript\r\nisNaN({}) // true\r\n// 等同於\r\nisNaN(Number({})) // true\r\n\r\nisNaN([\'xzy\']) // true\r\n// 等同於\r\nisNaN(Number([\'xzy\'])) // true\r\n```\r\n\r\n-  對於空陣列和只有一個數值成員的陣列\r\n\r\n```javascript\r\nisNaN([]) // false\r\nisNaN([123]) // false\r\nisNaN([\'123\']) // false\r\n```\r\n\r\n>  上面代碼之所以返回`false`，原因是這些陣列能被`Number`函數轉成數值\r\n\r\n-  因此，使用`isNaN`之前，最好判斷一下資料類型。\r\n\r\n```javascript\r\nfunction myIsNaN(value) {\r\n  return typeof value === \'number\' && isNaN(value);\r\n}\r\n```\r\n\r\n-  判斷`NaN`更可靠的方法是，利用`NaN`是JavaScript之中唯一不等於自身的值這個特點，進行判斷\r\n\r\n```javascript\r\nfunction myIsNaN(value) {\r\n  return value !== value;\r\n}\r\n```\r\n\r\n\r\n\r\n## 4.3 Infinity\r\n\r\n**（1）定義**\r\n\r\n-  `Infinity`表示“無窮”，用來表示兩種場景。一種是一個正的數值太大，或一個負的數值太小，無法表示；另一種是非0數值除以0，得到`Infinity`\r\n\r\n```javascript\r\n// 場景一\r\nMath.pow(2, Math.pow(2, 100))\r\n// 計算結果太大 Infinity\r\n\r\n// 場景二\r\n0 / 0 // NaN\r\n1 / 0 // Infinity\r\n```\r\n\r\n-  `Infinity`有正負之分，`Infinity`表示正的無窮，`-Infinity`表示負的無窮。\r\n\r\n```javascript\r\nInfinity === -Infinity // false\r\n\r\n1 / -0 // -Infinity\r\n-1 / -0 // Infinity\r\n```\r\n\r\n-  `Infinity`大於一切數值（除了`NaN`），`-Infinity`小於一切數值（除了`NaN`）\r\n\r\n```javascript\r\nInfinity > 1000 // true\r\n-Infinity < -1000 // true\r\n```\r\n\r\n-  `Infinity`與`NaN`比較，總是返回`false`。\r\n\r\n```javascript\r\nInfinity > NaN // false\r\n-Infinity > NaN // false\r\n\r\nInfinity < NaN // false\r\n-Infinity < NaN // false\r\n```\r\n\r\n\r\n\r\n**（2）運算規則**\r\n\r\n-  `Infinity`的四則運算，符合無窮的數學計算規則。\r\n\r\n```javascript\r\n5 * Infinity // Infinity\r\n5 - Infinity // -Infinity\r\nInfinity / 5 // Infinity\r\n5 / Infinity // 0\r\n```\r\n\r\n```javascript\r\n0 * Infinity // NaN\r\n0 / Infinity // 0\r\nInfinity / 0 // Infinity\r\n```\r\n\r\n-  `Infinity`與`null`計算時，`null`會轉成0，等同於與`0`的計算\r\n\r\n```javascript\r\nnull * Infinity // NaN\r\nnull / Infinity // 0\r\nInfinity / null // Infinity\r\n```\r\n\r\n-  `Infinity`與`undefined`計算，返回的都是`NaN`。\r\n\r\n```javascript\r\nundefined + Infinity // NaN\r\nundefined - Infinity // NaN\r\nundefined * Infinity // NaN\r\nundefined / Infinity // NaN\r\nInfinity / undefined // NaN\r\n```\r\n\r\n-  `Infinity`加上或乘以`Infinity`，返回的還是`Infinity`。\r\n\r\n```javascript\r\nInfinity + Infinity // Infinity\r\nInfinity * Infinity // Infinity\r\n```\r\n\r\n-  `Infinity`減去或除以`Infinity`，得到`NaN`\r\n\r\n```javascript\r\nInfinity - Infinity // NaN\r\nInfinity / Infinity // NaN\r\n```\r\n\r\n**（3）isFinite函數**\r\n\r\n`isFinite`函數返回一個布林值，檢查某個值是不是正常數值，而不是`Infinity`。\r\n\r\n```javascript\r\nisFinite(Infinity) // false\r\nisFinite(-1) // true\r\nisFinite(true) // true\r\nisFinite(NaN) // false\r\n```\r\n\r\n>  如果對`NaN`使用`isFinite`函數，也返回`false`，表示`NaN`不是一個正常值。\r\n\r\n\r\n\r\n## 5. 與數值相關的全域方法\r\n\r\n### 5.1 parseInt()\r\n\r\n**（1）基本用法**\r\n\r\n-  `parseInt`方法用於將字串轉為整數。\r\n\r\n```javascript\r\nparseInt(\'123\') // 123\r\n```\r\n\r\n-  如果字串頭部有空格，空格會被自動去除\r\n\r\n```javascript\r\nparseInt(\'   81\') // 81\r\n```\r\n\r\n-  如果`parseInt`的參數不是字串，則會先轉為字串再轉換。\r\n\r\n```javascript\r\nparseInt(1.23) // 1\r\n// 等同於\r\nparseInt(\'1.23\') // 1\r\n```\r\n\r\n-  如果遇到不能轉為數位的字元，就不再進行下去，返回已經轉好的部分。\r\n\r\n```javascript\r\nparseInt(\'8a\') // 8\r\nparseInt(\'12**\') // 12\r\nparseInt(\'12.34\') // 12\r\nparseInt(\'15e2\') // 15\r\nparseInt(\'15px\') // 15\r\n```\r\n\r\n-  如果字串的第一個字元不能轉化為數位（後面跟著數位的正負號除外），返回`NaN`。\r\n\r\n```javascript\r\nparseInt(\'abc\') // NaN\r\nparseInt(\'.3\') // NaN\r\nparseInt(\'\') // NaN\r\nparseInt(\'+\') // NaN\r\nparseInt(\'+1\') // 1\r\n```\r\n\r\n-  `parseInt`的返回值只有兩種可能，不是一個十進位整數，就是`NaN`。\r\n-  如果字串以`0x`或`0X`開頭，`parseInt`會將其按照十六進位數解析。\r\n\r\n```javascript\r\nparseInt(\'0x10\') // 16\r\n```\r\n\r\n-  如果字串以`0`開頭，將其按照10進制解析。\r\n\r\n```javascript\r\nparseInt(\'011\') // 11\r\n```\r\n\r\n-  對於那些會自動轉為科學計數法的數字，`parseInt`會將科學計數法的表示方法視為字串，因此導致一些奇怪的結果。\r\n\r\n```javascript\r\nparseInt(1000000000000000000000.5) // 1\r\n// 等同於\r\nparseInt(\'1e+21\') // 1\r\n\r\nparseInt(0.0000008) // 8\r\n// 等同於\r\nparseInt(\'8e-7\') // 8\r\n```\r\n\r\n\r\n\r\n**（2）進制轉換**\r\n\r\n-  `parseInt`方法還可以接受第二個參數（2到36之間），表示被解析的值的進制，返回該值對應的十進位數字。預設情況下，`parseInt`的第二個參數為10，即默認是十進位轉十進位。\r\n\r\n```javascript\r\nparseInt(\'1000\') // 1000\r\n// 等同於\r\nparseInt(\'1000\', 10) // 1000\r\n```\r\n\r\n```javascript\r\nparseInt(\'1000\', 2) // 8\r\nparseInt(\'1000\', 6) // 216\r\nparseInt(\'1000\', 8) // 512\r\n```\r\n\r\n>  上面代碼中，二進位、六進制、八進制的`1000`，分別等於十進位的8、216和512。這意味著，可以用`parseInt`方法進行進制的轉換。\r\n\r\n-  如果第二個參數不是數值，會被自動轉為一個整數。這個整數只有在2到36之間，才能得到有意義的結果，超出這個範圍，則返回`NaN`。如果第二個參數是`0`、`undefined`和`null`，則直接忽略。\r\n\r\n```javascript\r\nparseInt(\'10\', 37) // NaN\r\nparseInt(\'10\', 1) // NaN\r\nparseInt(\'10\', 0) // 10\r\nparseInt(\'10\', null) // 10\r\nparseInt(\'10\', undefined) // 10\r\n```\r\n\r\n-  如果字串包含對於指定進制無意義的字元，則從最高位元開始，只返回可以轉換的數值。如果最高位無法轉換，則直接返回`NaN`。\r\n\r\n```javascript\r\nparseInt(\'1546\', 2) // 1\r\nparseInt(\'546\', 2) // NaN\r\n```\r\n\r\n>  上面代碼中，對於二進位來說，`1`是有意義的字元，`5`、`4`、`6`都是無意義的字元，所以第一行返回1，第二行返回`NaN`。\r\n\r\n-  如果`parseInt`的第一個參數不是字串，會被先轉為字串。這會導致一些令人意外的結果。\r\n\r\n```javascript\r\nparseInt(0x11, 36) // 43\r\n// 等同於\r\nparseInt(String(0x11), 36)\r\nparseInt(\'17\', 36)\r\n```\r\n\r\n>  十六進位的`0x11`會被先轉為十進位的17，再轉為字串。然後，再用36進制解讀字串`17`，最後返回結果`43`\r\n\r\n```javascript\r\nparseInt(011, 2) // NaN\r\n// 等同於\r\nparseInt(String(011), 2)\r\n\r\nparseInt(\'011\', 2) // 3\r\n```\r\n\r\n>  上面代碼中，第一行的`011`會被先轉為字串`9`，因為`9`不是二進位的有效字元，所以返回`NaN`。第二行的字串`011`，會被當作二進位處理，返回3。\r\n\r\nES5不再允許將帶有首碼0的數位視為八進位數，而是要求忽略這個`0`。但是，為了保證相容性，大部分流覽器並沒有部署這一條規定。\r\n\r\n\r\n\r\n## 5.2 parseFloat()\r\n\r\n-  `parseFloat`方法用於將一個字串轉為浮點數。\r\n\r\n```javascript\r\nparseFloat(\'3.14\') // 3.14\r\n```\r\n\r\n-  如果字串符合科學計數法，則會進行相應的轉換。\r\n\r\n```javascript\r\nparseFloat(\'314e-2\') // 3.14\r\nparseFloat(\'0.0314E+2\') // 3.14\r\n```\r\n\r\n-  如果字串包含不能轉為浮點數的字元，則不再進行往後轉換，返回已經轉好的部分。\r\n\r\n```javascript\r\nparseFloat(\'3.14more non-digit characters\') // 3.14\r\n```\r\n\r\n-  `parseFloat`方法會自動過濾字串前導的空格。\r\n\r\n```javascript\r\nparseFloat(\'\\t\\v\\r12.34\\n \') // 12.34\r\n```\r\n\r\n-  如果參數不是字串，或者字串的第一個字元不能轉化為浮點數，則返回`NaN`。\r\n\r\n```javascript\r\nparseFloat([]) // NaN\r\nparseFloat(\'FF2\') // NaN\r\nparseFloat(\'\') // NaN\r\n```\r\n\r\n>  上面代碼中，尤其值得注意，`parseFloat`會將空字串轉為`NaN`。\r\n\r\n-  這些特點使得`parseFloat`的轉換結果不同於`Number`函數。\r\n\r\n```javascript\r\nparseFloat(true)  // NaN\r\nNumber(true) // 1\r\n\r\nparseFloat(null) // NaN\r\nNumber(null) // 0\r\n\r\nparseFloat(\'\') // NaN\r\nNumber(\'\') // 0\r\n\r\nparseFloat(\'123.45#\') // 123.45\r\nNumber(\'123.45#\') // NaN\r\n```\r\n\r\n',_binary '','2022-10-21 20:40:14','https://unsplash.it/800/600?4','轉載',_binary '',_binary '',_binary '','數值','2023-05-14 19:49:26',15,9,1,'前導0表示八進制，處理時很容易造成混亂。ES5的嚴格模式和ES6，已經廢除了這種標記法，但是流覽器目前還支持。'),(11,_binary '','我在試聽的內容當中已經給出了高效學習的定義，請允許我重新強調這個定義的內容。找到最適合自己的學習手法，在相對短的時間內集中注意力，以解決一個工作或生活當中的難題為目的著手學習。你需要勤加練習，有時候可能需要向名師求助。\r\n\r\n我給出的這個定義當中包含了關鍵字，有適合自己、學習方法、短時間、注意力、解決難題、設定目標，以及名師。我接下來會對這些關鍵字逐一展開來談。\r\n\r\n我現在首先要談的就是適合自己。也就是找到適合自己的學習方法，再進一步去到問題的根本，你的這個學習方法要適合你選擇的學習物件。\r\n\r\n**自然主義和結構主義**\r\n你可能試過學一門語言，或者學一樣樂器，費了半天勁也沒入門，那肯定就是學習方法錯了。你肯定是學英語上來先學語法了；學吉他上來照著譜子一頁一頁的摳基本功，這樣做可能不對。倒不是說因為這樣做在技能上完全沒有辦法提高，只不過是你選錯了學習方法，你選了一個低效的學習方法。你是在用結構主義的學習方法去學本來應該用自然主義學習方法去學的東西。\r\n\r\n那我在這裡面提到了自然主義和結構主義，這就是我重點要給你介紹的兩種學習方法。**自然主義核心它是模仿，結構主義為的是創造。**你要是學習比如像語言、樂器、書法這些東西，你可能要用自然主義的學習方法去學習才有效果。那如果你要是學比如像醫藥學、藝術，或者經濟學，那就應該用結構主義的方式來學了。\r\n\r\n我現在分別給你講講這兩種方法。\r\n先說自然主義的學習方法。自然主義的學習方法簡單來說就是模仿，自然主義注重文本的本身。什麼是文本？就是一門知識或者技能它表面上看起來的樣子，比如書法練習當中有個叫一絲不苟，就是這個意思。很多練習書法的人在臨摹古帖的時候，連古人寫錯了，用筆劃掉的那個東西，那個筆法也要模仿的一模一樣，這叫一絲不苟，這叫模仿。\r\n\r\n那麼結構主義它側重對結構和交互關係的一個認識，它提倡透過表面的現象去尋求底層的關係。也就是說**你要學習的是一套能舉一反三的系統**，這種訴求為的是什麼呢？為的是創造。比如當你瞭解了電子電路以後，你可以通過你學的這個原理自己創造出一台機器。但是，像英語這種東西，什麼時候輪到咱們來創造了？你學了半天語法，但是一句完整的，地道的英語都說不出來，也沒少見過這樣的人吧？\r\n\r\n咱們來對比一下，我們學會說中文，我們學語法了嗎？我們是超越了中文的本身去看到了中文背後那些系統與規則的東西嗎？難道不是我們父母和身邊的人他們說一句，我們學一句嗎？這不是自然主義嗎？那什麼東西應該用結構主義的方法來學呢？我說過，比如像**醫藥學、藝術，或者是經濟學**，這類學科它需要創造的學科。你還真得用結構主義的方法來學。\r\n\r\n你可能會說醫藥學怎麼就創造了呢？因為我們需要治病，而治病它屬於創造。人生了病這是事物發生了一種現象。你不能再用自然主義的那套模仿的方法來治病了，要不然你就會陷入以形補形的那個誤區。什麼是以形補形啊？很多人相信吃啥補啥，這就是以形補形。說因為核桃仁跟人腦長的很像，所以吃核桃仁能補腦。這種就特別的自然主義。還有人說，吃豬肺可以清肺，它也是一種基於吃啥補啥的所謂的理論帶出來的一種妄想。當然了，有人說了，核桃仁成分當中有脂肪和蛋白，而這個脂類的攝入對人的大腦是有好處的。那你要是這麼說的話，我就選擇相信你，因為這是屬於結構主義的結論。\r\n\r\n我也說過了，學藝術比較適合用結構主義的方法來學。因為藝術存在的意義就在於創造。如果用自然主義的方法去學藝術，你只會學到藝術史，你沒有自己的創造，你永遠也成不了藝術家。在藝術上一味的去進行模仿，只會讓人鄙視。\r\n\r\n現在你知道，**這個學習方法主要分兩種，一種是自然主義，一種是結構主義**。自然主義是模仿式的學習，遇到什麼就學什麼，積少成多，以量取勝。學完了就那樣了，它就是你自己的了，**你就可以去運用了**。結構主義是說學東西的時候更注重一個結構，體系化的去學習。學會之後的目的，你要注意，一定是為了創造，是一種質變，它要的是一種質變。那面對不同的學問，你不要選錯學習方法，要不然的話你的學習很可能就是無效的。\r\n\r\n練習不必顧全大局\r\n掌握了適合的學習方法，你的學習肯定是有效的了。但是，有效也可能是低效的。怎麼從有效變成高效？學習速度和效率的提升理論上可以分為兩個階段。一個是避免無效學習，那學習的速度和效率自然就得以提升了。另一個就是盡可能通過更好的學習方法來把這個有效變為高效。\r\n\r\n怎麼樣做是更好的學習方法？最簡單的就是把你的**目標要拆碎**，針對那些細節進行反復的練習。不要一開始就照顧全域。比如演奏一首樂曲，你不要每次練習的時候都從曲子的開頭一直演奏到結尾，中間遇到一些彈不熟的就糊弄過去了，就把它順過去了，這樣做效率是很低的。你應該每天只練好這個曲子當中的一句，在音樂當中它叫“樂句”，就是一句，可能是8個小節，你每天就練8個小節，每天就只練這8個小節。\r\n\r\n我再給你舉一個高效學習的例子，比如說足球運動員在訓練的時候，有時候他們訓練的是什麼？是球員的球感，個人的技術，以及相互之間的配合。如果是訓練這些方面的話，那要想達到一個高效的訓練結果，往往他們不會在那種標準的足球場進行訓練，反而會在比較小的五人制足球場進行訓練。這樣做的好處是什麼呢？單位時間裡球員的觸球機會會更多，不用在一個標準的大球場裡邊進行無效的來回跑動。這樣訓練下來，這些球員的球感，個人技術和相互之間的配合就可以高效的提升了。\r\n\r\n碎片化學習的真相\r\n在有了高效學習方法之後，如果再能擠出更多的時間來學習，那你的進步一定是突飛猛進的。所以，學習的時間安排也是一個需要考慮的問題。對成年人來講，當然最好能端正的坐在圖書館裡邊學習了，但是我們每天還要面對各種各樣的雜事，碎片化的學習可能是我們學習的唯一方式了，總比不學要強嘛。\r\n\r\n怎麼能在碎片化的時間裡邊更高效的去學習？我告訴你一個方法，**你要帶著困惑和問題進行學習**，多使用搜索這個功能。碎片化學習它不是這兒弄一點，那兒弄一點，那叫熊瞎子掰苞米。碎片化學習的真相是碎片化學習一定要基於搜索，搜索是什麼意思？意思就是你要帶著困惑和問題去執行碎片化的學習。你總不可能同一時間什麼都學嘛。等你手裡邊有了一些閒錢，你可能就想學學理財了；當你的孩子出生了，你就會想去學學育兒的理念。不是這樣嗎？當你不能去報一個理財班或者育兒課的時候，你沒有整塊的時間來學習，那碎片化的吸收相關的知識有什麼不好呢？\r\n\r\n**帶著困惑和問題去執行碎片化的學習，最終的效果一定是要把這些碎片給連結起來**。在一段時間內，你的頭腦當中應該始終有一個課題，這些碎片它不是滿地的落葉，而是我們可以把它比喻成一個打碎的瓷器所產生的碎片。你要有目的的去拾獲這些碎片，而不是亂撿。就算碎片化知識是樹葉，你也得先有樹根、樹幹和樹枝。碎片化學習要的是枝繁葉茂，而不是撿幾片樹葉回來夾在書裡邊。那就屬於一種情緒化的行為。所以說，小孩可能不適合碎片化的學習，因為小孩他是沒有樹根、樹幹和樹枝的。\r\n\r\n話說回來，碎片化學習它終究是有局限性的，因為它缺乏思考，缺乏辯論，缺乏與人交流的這些環節。所謂學而不思則罔嘛。碎片劃拉的越多，可能越糊塗了。但是，無論如何，碎片化學習作為一種成年人學習的補充手段，無疑它是有很大力量的。\r\n\r\n我自己最近對經濟學有了一些困惑，我就在用碎片化學習的模式，在咱們得到的平臺在聽薛兆豐老師的《薛兆豐的北大經濟學課》。我收穫很大，我也推薦你聽一聽，如果你對經濟學也有一些搞不懂的地方，或者說有一些興趣，關心自己每天的行為，日常的生活跟經濟學有什麼樣的關係，用經濟學怎麼樣去解釋這些東西，我推薦你聽一聽這個課。\r\n\r\n我還要提醒你一件事情，有一種假的碎片化學習叫做收藏。你一定對這個東西非常熟悉，收藏這個按鈕是非常常見的，在很多app和軟體當中，所謂一種人性化的設置。它的存在能夠非常大程度緩解人們的焦慮。但這種緩解它其實不是真正的緩解，它只是給你造成一種幻覺，就是收藏了這些知識就是你的了。但其實，如果你收藏完了不看的話，你不去碰它，它並不是你的。你必須要破除掉這種幻覺。\r\n\r\n我自己有一個很深的體會，我在教英語的時候，我觀察到很多學生他上課的時候會瘋狂地記筆記，後來乾脆有學生把我們老師講課的內容完整地錄下來，說等回家以後要反復的聽。但是我發現他們沒有一個人錄下來之後能反復聽，哪怕聽一遍都做不到。我自己從來不收藏任何東西。\r\n\r\n小結\r\n總結一下這節課，我給你介紹了兩種學習方法：一種是自然主義，一種是結構主義。自然主義是模仿，遇到什麼就學什麼，學習過程可以是碎片化的，積少成多，注重量的積累。結構主義學東西更注重結構，體系化的去學，學會之後的目的是創造。為的是一種質變。你選擇了正確的學習方法之後，把這個目標拆碎，針對細節進行反復的練習。如果再能以碎片化的方式擠出更多的時間來學習的話，那就會更好。\r\n\r\n那聽到這裡，我猜你可能會有一個疑問。你可能在想，你許岑說起學習頭頭是道，但你的這套學習方法難道對所有的知識門類的學習都管用嗎？在下一次的\r\n',_binary '','2022-10-21 20:29:42','https://unsplash.it/800/600?5','原創',_binary '',_binary '',_binary '','選擇正確學習方法','2023-05-14 19:45:37',3,10,1,'我在試聽的內容當中已經給出了高效學習的定義，請允許我重新強調這個定義的內容。找到最適合自己的學習手法，在相對短的時間內集中注意力，以解決一個工作或生活當中的難題為目的著手學習。你需要勤加練習，有時候可能需要向名師求助。'),(12,_binary '','> 《通往財富自由之路》-學習感悟\r\n\r\n## （1）\r\n\r\n現在的這個時代變了，而且變得越來越好了。\r\n\r\n互聯網的高速發展，資訊低成本流通，使人與人之間的連接成本趨近於零，連接的節點數趨於“無窮”。一個真正有能力的個體在這個時代，不依賴於任何組織的前提下，真的可以實現“財富自由”。對於我們“凡人”來說，實現個人財富自由並非遙不可及！\r\n\r\n正確做好任何一件事情的前提是清晰、正確的理解目標。而事實是，我們很多人很多時候根本沒有對目標正確的定義，甚至根本從來就沒有想過，只是大家都那麼做而已...\r\n\r\n語言學家告訴我們，**如果腦子裡沒有一個清楚的概念的話，我們的大腦就傾向於不去想那個事情**，更別說正確的思考，從而指導我們正確的實踐。這樣看來，如果對目標沒有清晰正確的定義，那實現目標也就無從談起。\r\n\r\n**清晰、正確的概念是一切思考的基石。**\r\n\r\n所以在我們做一件事情之前，能不能先考慮清楚？能不能給它一個清晰、正確的定義呢？就像題目中的“財富自由”，你真的理解嗎？\r\n\r\n## （2）\r\n\r\n財富自由，是一個讓人心裡發熱、發癢又興奮也很無奈的詞兒，特別是在在這個“黑天鵝”到處飛的時代！\r\n\r\n>  “有很多的錢（你自己賺的，你老爹給的...），不用工作，遊遍千山萬水，吃遍山珍海味，老子想去哪兒就去哪兒，想幹嘛就幹嘛”\r\n\r\n這可能是大多數人第一個想到的財富自由的定義咯，“財富自由嘛，就是錢很多嘛，然後很自由咯，沒啥高深的嘛”。不好意思的告訴你哦，這樣的定義只是你大腦意淫的結果，僅此而已。\r\n\r\n>  **財務自由**是指你無需為生活開銷而努力為錢工作的狀態\r\n\r\n這是維琪百科給出的定義，這個定義算是清晰說出了“財富自由”的狀態，但還是沒有給出我們具有指導意義的定義，一個清晰、正確、準確的定義，能夠給我們實際的指導意義。\r\n\r\n**財富自由的重點在“自由”**，什麼的自由？時間的自由。我們的時間能夠真正屬於自己，而不必在意來自外部的壓力？而現實中，我們為什麼不能自由支配自己的時間呢？很明顯嘛，我們要工作呀，要掙錢養家呀，要掙錢還房貸呀。這些，我們都是在做一件事兒：出賣自己的時間，來換得生活必需的基礎。所以：\r\n\r\n**所謂的財富自由是指某個人不必再為了生活必需而出賣自己的時間**\r\n\r\n所以，關鍵點在“時間”上。在實現財富自由之前我們依然要出賣自己的時間，因為你先要保證能**活著**。即便是這樣，在“出賣時間”上我們依然需要有更好的選擇，從而不在通往財富自由的路上越走越遠。什麼更好的選擇呢？多用腦瓜子琢磨琢磨也許你會想得到。\r\n\r\n像我們這種打工一族首選會想到的就是：**提高時薪**，即是每個小時的工資，更直白點就是**工資**啦。你”賣命於“一個特定的組織，你的時間某種意義上是賣給了你的所在組織（公司啦）。怎麼樣賣的好一點呀？就是賣貴點啦，那就要想辦法讓你的領導給你加工資咯。所以有部分人就好好工作，讓領導看到你的價值，來提高時薪。你工作很賣命，天天加班累成狗。摳了吧唧的公司還不給加工資。所以，你“豪氣萬丈”做了很“牛逼”的決定：“老子不伺候啦，老子要跳槽”。對，很多人都是這麼做的。\r\n\r\n所以你就跳來跳去，等跳不動了，似乎想“明白”啦，立志好好幹，成為某某某一樣要年薪多少多少，於是乎決定要在一家公司好好幹，幹出個人模狗樣。然後呢，然後就沒然後啦…\r\n\r\n那是不是還有另外一種選擇呢？\r\n\r\n**把一份時間想辦法賣出去更多份**。這裡可不是說讓你找幾個兼職幹，找兼職本質上還是沒有把一份時間賣出去很多份，你一份時間也只能對應賣個一個組織。比如：出一本暢銷書，做一個受歡迎的產品，一個好的視頻教程…，用你的一份時間產生價值，然後賣給很多人。\r\n\r\n怎麼做呢？\r\n\r\n第一步，要考慮的是：你的一份時間如何產生價值？\r\n\r\n首先你要清楚 “價值” 的定義，現在你已經知道一個清晰準確的定義有多麼重要啦。既然要把價值賣出去很多份，那是不是我們的價值要對很多人真的有用，人家才願意買。那麼問題來了，怎麼才能對很多人有用？那很明顯，你要知道 “很多人都需要什麼”，即需求。\r\n\r\n接下來你要做的是真的有用，即真的滿足”很多人“的需求。\r\n\r\n這樣才算是“你的時間產生了價值”。\r\n\r\n第二步，要做的是，怎麼把你的價值賣出去？\r\n\r\n>  可不是發發朋友圈那麼簡單\r\n\r\n要賣出去，就先要讓人家知道你的價值，把你的價值傳播出去。這麼簡單的道理大家都懂，怎麼讓人家知道你的價值？\r\n\r\n-  你要想辦法和很多人建立連接，而且是強**連接**\r\n-  你要增強自己的影響力，在影響力基礎上的傳播才是有效傳播。\r\n\r\n看看這麼些簡單的道理，我們有時候用腦瓜子琢磨琢磨，也會弄出來個一二三。所以**多動動我們的腦瓜子，別讓它睡著了**。\r\n\r\n現在知道了：\r\n\r\n**財富自由是指某個人不必再為了生活必需而出賣自己的時間**\r\n\r\n即便是出賣自己的時間也不止一種選擇，比如還有：**把一份時間想辦法賣出去更多份**。\r\n\r\n## （3）\r\n\r\n到這，已經知道了財富自由的正確定義了，但是不要掉入另外一個坑：\r\n\r\n**千萬不要以為財富自由是終點，財富自由不是終點**\r\n\r\n財富自由是終點，當你這樣想的時候，基本上沒有希望實現財富自由啦。當我們這樣想的時候，腦子裡就會有亂七八糟的想法，從而會影響我們的選擇判斷，你可能會認為某個其實不重要東西更重要，發生價值觀上的扭曲。好像在你通往財富自由的路上胡亂改變方向，要花費很大的時間和精力才能到達終點，甚至在中途迷路，南轅北轍，永遠到達不了終點。就像一個無頭蒼蠅似的亂飛，始終無法以最理想的速度靠近目標。\r\n\r\n可是，我們很多人對財富自由的認知僅僅是這樣：\r\n\r\n**等我有了錢，我就......**\r\n\r\n這樣的想法有多危險，比如說：“等我賺夠了錢，我就天天打遊戲”。這時候你會認為打遊戲是一件很有價值的事情，因為只有你實現財富自由之後才能去做。潛意識裡把本沒有多少價值的事情錯誤的認為很重要，無形中會忽略我們現在正在做的事情（很辛苦，但很有價值），比如努力工作，開發一個IT產品。沒有足夠的注意力（很寶貴的資源）投入在更有價值的事情之上，長期來看，我們只能會原地踏步，甚至退步。\r\n\r\n所以要清醒，財富自由之後，還是會不斷做的事情，比如專注成長。我們從小就被教育，要成功，要成功。很多人就把成功作為窮其一生追求的目標。但不論你怎麼成功，依然需要成長，否則，人類社會也不會那麼快的進步。所以：\r\n\r\n**財富自由不是終點，那只是通往終點的一個里程碑而已**\r\n\r\n路漫漫其修遠兮，吾將上下而求索。\r\n\r\n這僅僅是個開始......\r\n',_binary '','2022-10-23 19:46:30','https://unsplash.it/800/600?6','原創',_binary '\0',_binary '',_binary '','你真理解甚麼是財富自由嗎？','2023-05-14 19:47:29',2,11,1,'正確做好任何一件事情的前提是清晰、正確的理解目標。而事實是，我們很多人很多時候根本沒有對目標正確的定義，甚至根本從來就沒有想過，只是大家都那麼做而已…'),(13,_binary '','人人都渴望成功，而且是越快速越好，誰想失敗？且失敗還要趁早？其實道理很簡單，你一定很早就知道。簡單的可能你都不會相信，甚至不屑。是什麼呢？\r\n\r\n\r\n## 失敗乃成功之母\r\n\r\n這個我們從小就知道的道理。但是這句話的意思你真的理解嗎？《漢語成語大詞典》中對“失敗乃成功之母”是這樣解釋的：母，先導。它指人唯有善於從失敗中吸取經驗教訓，才能獲得成功。**失敗是成功的先導，失敗是成功的基礎**。（母的意義不是母親而是基礎）。\r\n\r\n\r\n\r\n## 難道所有成功必須經歷失敗嗎？\r\n\r\n你難免會有這樣的疑問？那我們這樣想一下，古往今來有誰輕而易舉的獲得過很大的成功？再者說不費點勁，不經歷過失敗的就能輕鬆做成的事兒，真的還有那麼大的價值嗎？有一定價值的事情不是那麼輕易就能做成，能輕易做成的事情，很多人都可以做成，價值某種程度上就會減小。所以我這樣理解：**有價值的成功，不會輕易獲得，必然要先經歷失敗**，再翻譯下就是：**失敗是成功的起點，沒有經歷失敗之前你都沒有進入通往成功的跑道**，所以某種意義上來說，失敗是必然存在的，是通往成功的階梯。既然這樣，我們有什麼理由不坦然面對失敗，甚至高興的去面對失敗呢？\r\n\r\n**失敗要趁早，越早失敗才有可能早點遇到成功**，那麼話又說回來，失敗難到不是很容易就能做到的事情嗎？但是你是否想過，一件事情失敗的前提條件是實實在在的去做這件事兒，這樣你才有了失敗的機會，有了失敗，你才有了吸取教訓的機會，才有希望遇到成功。任何事兒不去做，失敗你都沒得機會，就別想要成功啦。**快速開始，才是開始成功的正確姿勢**，如何快速開始呢？\r\n\r\n\r\n\r\n## 不要想太多，勇敢嘗試\r\n\r\n頭天晚上想了千條路，早上醒來走老路。總有那麼一些人（有時候我也是這樣）永遠讓事情止於意淫。而且還會找各種理由說服自己：“還沒準備好”，“這樣做到底行不行？”，“有人成功過沒”…  永遠邁不出去第一步，所以就淪為“凡人”。**人生苦短，不要想太多，想好了就去做，這樣才有成功的機會**\r\n\r\n\r\n\r\n## 放下你臆想的完美主義\r\n\r\n臆想的完美主義，只會讓你更糾結，更痛苦，讓你在成功的路上越走越遠。\r\n\r\n高中那會總是企圖做一個完美學習計畫，然後臆想通過執行計畫可以把成績飛速提升，然而都以失敗告終，因為一直在做計畫的路上，要不就是在修改計畫的路上。\r\n\r\n任何事情不會一下子就會做到極致，誰又是一開始就能把事情做到完美呢。只要開始做，哪怕一天一點點，都會離成功越來越近。這些你都懂，然卵用。因為你沒有放下臆想的完美主義。趕快，搞起來吧，騷年\r\n\r\n\r\n\r\n## 專注目標，不要朝三暮四\r\n\r\n正確的做事方法，**要專注於眼前的目標**，不要做著這個事情，還想著其他的事情，搞得啥都沒做好，還浪費了我們寶貴的注意力。集中注意力先把你眼前力所能及的事情做好，讓自己得到正回饋，這樣才能得到鼓勵，動力越來越足，事情越做越好。否則，朝三暮四去了，會把你空虛一大把。\r\n',_binary '','2022-10-23 19:47:55','https://unsplash.it/800/600?7','原創',_binary '',_binary '',_binary '','失敗要趁早','2023-05-14 19:48:06',4,11,1,'人人都渴望成功，而且是越快速越好，誰想失敗？且失敗還要趁早？其實道理很簡單，你一定很早就知道。簡單的可能你都不會相信，甚至不屑。是什麼呢？'),(14,_binary '','# 用戶故事（User Story）\r\n\r\n## 1、User Story是什麼？\r\n\r\n-  User Story 是敏捷開發框架會用到的一個開發方法。\r\n-  User Story是使用者對軟體的功能敘述。\r\n-  User Story 的關鍵點：角色、功能、商業價值\r\n-  User Story範本：\r\n   -  As a (role of user), I want (some feature) so that (some business value).\r\n   -  作為一個(某個角色) 使用者，我可以做(某個功能) 事情，如此可以有(某個商業價值) 的好處\r\n-  舉例：\r\n   -  作為一個招聘網站註冊用戶，我想查看最近3天發佈的招聘資訊，以便於瞭解最新的招聘資訊。\r\n   -  作為公司可以張貼新工作\r\n\r\n## 2、編寫用戶故事\r\n\r\n-  **客戶編寫**：使用者故事最好由客戶或者軟體使用者來編寫，非開發人員編寫。\r\n-  **卡片（Card）**：使用者故事一般在小卡片上寫著故事的簡短描述，工作量估算等。\r\n-  **交談（Conversation）**：使用者故事背後的細節來源於和客戶或者產品負責人的交流溝通。\r\n-  **確認（Confirmation）**：通過接受度測試確認用戶故事被正確完成。\r\n\r\n## 3、User Story的特點\r\n\r\n-  **溝通**：使用者故事不是詳細需求，是開發者和客戶之間溝通的“媒介”。\r\n-  **易懂**：用戶故事簡單易懂，不包含專業術語。\r\n-  **足夠小**：用戶故事不要太大，能夠估算工足量。（開發者1到2個工作日可完成）\r\n-  **適於反覆運算**：適合反覆運算開發，不需要一開始寫出所有的用戶故事。\r\n-  **延後細節**：用戶故事由大到小拆分，夠用就好，不要一開始確定所有細節。\r\n-  **多角色參與**：鼓勵使用者與開發者參與。\r\n\r\n## 4、用戶故事原則\r\n\r\n-  **獨立**：避免不同用戶故事相互依賴。\r\n-  **可討論**：不要帶有太多細節，能夠與客戶彈性套路。\r\n-  **有價值**：由客戶編寫，清晰體現對使用者或客戶的商業價值。\r\n-  **可估算**： 可以根據使用者故事故事工作量，確定優先順序，安排計畫。\r\n-  **足夠小**：用戶故事足夠小，儘量不要超過10個人日工作量，至少確保可以在一個反覆運算週期中完成。\r\n-  **可測試**：用戶故事要確保可以測試，能夠確定是否完成。\r\n',_binary '','2022-10-23 19:49:15','https://unsplash.it/800/600?8','原創',_binary '',_binary '',_binary '','User Story','2023-05-14 19:48:26',2,14,1,'人人都渴望成功，而且是越快速越好，誰想失敗？且失敗還要趁早？其實道理很簡單，你User Story 是敏捷開發框架會用到的一個開發方法。開發者應該學會這種方法，從用戶的角度去瞭解需求，從而剛好的把需求實現為有價值的功能'),(15,_binary '','## 概述\r\n\r\n### 生成方法\r\n\r\n物件（object）是JavaScript的核心概念，也是最重要的資料類型。JavaScript的所有資料都可以被視為物件。\r\n\r\n簡單說，所謂物件，就是一種無序的資料集合，由若干個“鍵值對”（key-value）構成。\r\n\r\n```JavaScript\r\nvar o = {\r\n  p: \'Hello World\'\r\n};\r\n```\r\n\r\n上面代碼中，大括弧就定義了一個物件，它被賦值給變數`o`。這個物件內部包含一個鍵值對（又稱為“成員”），`p`是“鍵名”（成員的名稱），字串`Hello World`是“鍵值”（成員的值）。鍵名與鍵值之間用冒號分隔。如果物件內部包含多個鍵值對，每個鍵值對之間用逗號分隔。\r\n\r\n```JavaScript\r\nvar o = {\r\n  p1: \'Hello\',\r\n  p2: \'World\'\r\n};\r\n```\r\n\r\n物件的生成方法，通常有三種方法。除了像上面那樣直接使用大括弧生成（`{}`），還可以用`new`命令生成一個`Object`物件的實例，或者使用`Object.create`方法生成。\r\n\r\n```JavaScript\r\nvar o1 = {};\r\nvar o2 = new Object();\r\nvar o3 = Object.create(Object.prototype);\r\n```\r\n\r\n上面三行語句是等價的。一般來說，第一種採用大括弧的寫法比較簡潔，第二種採用構造函數的寫法清晰地表示了意圖，第三種寫法一般用在需要物件繼承的場合。關於第二種寫法，詳見《標準庫》一章的《Object 物件》一節，第三種寫法詳見《物件導向程式設計》一章。\r\n\r\n### 鍵名\r\n\r\n物件的所有鍵名都是字串，所以加不加引號都可以。上面的代碼也可以寫成下面這樣。\r\n\r\n```JavaScript\r\nvar o = {\r\n  \'p\': \'Hello World\'\r\n};\r\n```\r\n\r\n如果鍵名是數值，會被自動轉為字串。\r\n\r\n```JavaScript\r\nvar o ={\r\n  1: \'a\',\r\n  3.2: \'b\',\r\n  1e2: true,\r\n  1e-2: true,\r\n  .234: true,\r\n  0xFF: true\r\n};\r\n\r\no\r\n// Object {\r\n//   1: \"a\",\r\n//   3.2: \"b\",\r\n//   100: true,\r\n//   0.01: true,\r\n//   0.234: true,\r\n//   255: true\r\n// }\r\n```\r\n\r\n但是，如果鍵名不符合標識名的條件（比如第一個字元為數位，或者含有空格或運算子），也不是數字，則必須加上引號，否則會報錯。\r\n\r\n```JavaScript\r\nvar o = {\r\n  \'1p\': \"Hello World\",\r\n  \'h w\': \"Hello World\",\r\n  \'p+q\': \"Hello World\"\r\n};\r\n```\r\n\r\n上面物件的三個鍵名，都不符合標識名的條件，所以必須加上引號。\r\n\r\n注意，JavaScript的保留字可以不加引號當作鍵名。\r\n\r\n```JavaScript\r\nvar obj = {\r\n  for: 1,\r\n  class: 2\r\n};\r\n```\r\n\r\n### 屬性\r\n\r\n物件的每一個“鍵名”又稱為“屬性”（property），它的“鍵值”可以是任何資料類型。如果一個屬性的值為函數，通常把這個屬性稱為“方法”，它可以像函數那樣調用。\r\n\r\n```JavaScript\r\nvar o = {\r\n  p: function (x) {\r\n    return 2 * x;\r\n  }\r\n};\r\n\r\no.p(1)\r\n// 2\r\n```\r\n\r\n上面的物件就有一個方法`p`，它就是一個函數。\r\n\r\n物件的屬性之間用逗號分隔，最後一個屬性後面可以加逗號（trailing comma），也可以不加。\r\n\r\n```JavaScript\r\nvar o = {\r\n  p: 123,\r\n  m: function () { ... },\r\n}\r\n```\r\n\r\n上面的代碼中`m`屬性後面的那個逗號，有或沒有都不算錯。\r\n\r\n屬性可以動態創建，不必在物件聲明時就指定。\r\n\r\n```JavaScript\r\nvar obj = {};\r\nobj.foo = 123;\r\nobj.foo // 123\r\n```\r\n\r\n上面代碼中，直接對`obj`物件的`foo`屬性賦值，結果就在運行時創建了`foo`屬性。\r\n\r\n### 物件的引用\r\n\r\n如果不同的變數名指向同一個物件，那麼它們都是這個物件的引用，也就是說指向同一個記憶體位址。修改其中一個變數，會影響到其他所有變數。\r\n\r\n```JavaScript\r\nvar o1 = {};\r\nvar o2 = o1;\r\n\r\no1.a = 1;\r\no2.a // 1\r\n\r\no2.b = 2;\r\no1.b // 2\r\n```\r\n\r\n上面代碼中，`o1`和`o2`指向同一個物件，因此為其中任何一個變數添加屬性，另一個變數都可以讀寫該屬性。\r\n\r\n此時，如果取消某一個變數對於原物件的引用，不會影響到另一個變數。\r\n\r\n```JavaScript\r\nvar o1 = {};\r\nvar o2 = o1;\r\n\r\no1 = 1;\r\no2 // {}\r\n```\r\n\r\n上面代碼中，`o1`和`o2`指向同一個物件，然後`o1`的值變為1，這時不會對`o2`產生影響，`o2`還是指向原來的那個物件。\r\n\r\n但是，這種引用只局限於物件，對於原始類型的資料則是傳值引用，也就是說，都是值的拷貝。\r\n\r\n```JavaScript\r\nvar x = 1;\r\nvar y = x;\r\n\r\nx = 2;\r\ny // 1\r\n```\r\n\r\n上面的代碼中，當`x`的值發生變化後，`y`的值並不變，這就表示`y`和`x`並不是指向同一個記憶體位址。\r\n\r\n### 運算式還是語句？\r\n\r\n物件採用大括弧表示，這導致了一個問題：如果行首是一個大括弧，它到底是運算式還是語句？\r\n\r\n```JavaScript\r\n{ foo: 123 }\r\n```\r\n\r\nJavaScript引擎讀到上面這行代碼，會發現可能有兩種含義。第一種可能是，這是一個運算式，表示一個包含`foo`屬性的物件；第二種可能是，這是一個語句，表示一個代碼區塊，裡面有一個標籤`foo`，指向運算式`123`。\r\n\r\n為了避免這種歧義，JavaScript規定，如果行首是大括弧，一律解釋為語句（即代碼塊）。如果要解釋為運算式（即物件），必須在大括弧前加上圓括號。\r\n\r\n```JavaScript\r\n({ foo: 123})\r\n```\r\n\r\n這種差異在`eval`語句中反映得最明顯。\r\n\r\n```JavaScript\r\neval(\'{foo: 123}\') // 123\r\neval(\'({foo: 123})\') // {foo: 123}\r\n```\r\n\r\n上面代碼中，如果沒有圓括號，`eval`將其理解為一個代碼塊；加上圓括號以後，就理解成一個物件。\r\n\r\n## 屬性的操作\r\n\r\n### 讀取屬性\r\n\r\n讀取物件的屬性，有兩種方法，一種是使用點運算子，還有一種是使用方括號運算子。\r\n\r\n```JavaScript\r\nvar o = {\r\n  p: \'Hello World\'\r\n};\r\n\r\no.p // \"Hello World\"\r\no[\'p\'] // \"Hello World\"\r\n```\r\n\r\n上面代碼分別採用點運算子和方括號運算子，讀取屬性`p`。\r\n\r\n請注意，如果使用方括號運算子，鍵名必須放在引號裡面，否則會被當作變數處理。但是，數位鍵可以不加引號，因為會被當作字串處理。\r\n\r\n```JavaScript\r\nvar o = {\r\n  0.7: \'Hello World\'\r\n};\r\n\r\no[\'0.7\'] // \"Hello World\"\r\no[0.7] // \"Hello World\"\r\n```\r\n\r\n方括號運算子內部可以使用運算式。\r\n\r\n```JavaScript\r\no[\'hello\' + \' world\']\r\no[3 + 3]\r\n```\r\n\r\n數值鍵名不能使用點運算子（因為會被當成小數點），只能使用方括號運算子。\r\n\r\n```JavaScript\r\nobj.0xFF\r\n// SyntaxError: Unexpected token\r\nobj[0xFF]\r\n// true\r\n```\r\n\r\n上面代碼的第一個運算式，對數值鍵名`0xFF`使用點運算子，結果報錯。第二個運算式使用方括號運算子，結果就是正確的。\r\n\r\n### 檢查變數是否聲明\r\n\r\n如果讀取一個不存在的鍵，會返回`undefined`，而不是報錯。可以利用這一點，來檢查一個全域變數是否被聲明。\r\n\r\n```JavaScript\r\n// 檢查a變數是否被聲明\r\nif (a) {...} // 報錯\r\n\r\nif (window.a) {...} // 不報錯\r\nif (window[\'a\']) {...} // 不報錯\r\n```\r\n\r\n上面的後二種寫法之所以不報錯，是因為在流覽器環境，所有全域變數都是`window`物件的屬性。`window.a`的含義就是讀取`window`物件的`a`屬性，如果該屬性不存在，就返回`undefined`，並不會報錯。\r\n\r\n需要注意的是，後二種寫法有漏洞，如果`a`屬性是一個空字串（或其他對應的布林值為`false`的情況），則無法起到檢查變數是否聲明的作用。正確的做法是可以採用下面的寫法。\r\n\r\n```JavaScript\r\nif (\'a\' in window) {\r\n  // 變數 a 聲明過\r\n} else {\r\n  // 變數 a 未聲明\r\n}\r\n```\r\n\r\n### 屬性的賦值\r\n\r\n點運算子和方括號運算子，不僅可以用來讀取值，還可以用來賦值。\r\n\r\n```JavaScript\r\no.p = \'abc\';\r\no[\'p\'] = \'abc\';\r\n```\r\n\r\n上面代碼分別使用點運算子和方括號運算子，對屬性p賦值。\r\n\r\nJavaScript允許屬性的“後綁定”，也就是說，你可以在任意時刻新增屬性，沒必要在定義物件的時候，就定義好屬性。\r\n\r\n```JavaScript\r\nvar o = { p: 1 };\r\n\r\n// 等價於\r\n\r\nvar o = {};\r\no.p = 1;\r\n```\r\n\r\n### 查看所有屬性\r\n\r\n查看一個物件本身的所有屬性，可以使用`Object.keys`方法。\r\n\r\n```JavaScript\r\nvar o = {\r\n  key1: 1,\r\n  key2: 2\r\n};\r\n\r\nObject.keys(o);\r\n// [\'key1\', \'key2\']\r\n```\r\n\r\n### delete命令\r\n\r\n`delete`命令用於刪除物件的屬性，刪除成功後返回`true`。\r\n\r\n```JavaScript\r\nvar o = {p: 1};\r\nObject.keys(o) // [\"p\"]\r\n\r\ndelete o.p // true\r\no.p // undefined\r\nObject.keys(o) // []\r\n```\r\n\r\n上面代碼中，`delete`命令刪除`o`物件的`p`屬性。刪除後，再讀取`p`屬性就會返回`undefined`，而且`Object.keys`方法的返回值中，`o`物件也不再包括該屬性。\r\n\r\n注意，刪除一個不存在的屬性，`delete`不報錯，而且返回`true`。\r\n\r\n```JavaScript\r\nvar o = {};\r\ndelete o.p // true\r\n```\r\n\r\n上面代碼中，`o`物件並沒有`p`屬性，但是`delete`命令照樣返回`true`。因此，不能根據`delete`命令的結果，認定某個屬性是存在的，只能保證讀取這個屬性肯定得到`undefined`。\r\n\r\n只有一種情況，`delete`命令會返回`false`，那就是該屬性存在，且不得刪除。\r\n\r\n```JavaScript\r\nvar o = Object.defineProperty({}, \'p\', {\r\n  value: 123,\r\n  configurable: false\r\n});\r\n\r\no.p // 123\r\ndelete o.p // false\r\n```\r\n\r\n上面代碼之中，`o`物件的`p`屬性是不能刪除的，所以`delete`命令返回`false`（關於`Object.defineProperty`方法的介紹，請看《標準庫》一章的`Object`物件章節）。\r\n\r\n另外，需要注意的是，`delete`命令只能刪除物件本身的屬性，無法刪除繼承的屬性（關於繼承參見《物件導向程式設計》一節）。\r\n\r\n```JavaScript\r\nvar o = {};\r\ndelete o.toString // true\r\no.toString // function toString() { [native code] }\r\n```\r\n\r\n上面代碼中，`toString`是物件`o`繼承的屬性，雖然`delete`命令返回`true`，但該屬性並沒有被刪除，依然存在。\r\n\r\n最後，`delete`命令不能刪除`var`命令聲明的變數，只能用來刪除屬性。\r\n\r\n```JavaScript\r\nvar p = 1;\r\ndelete p // false\r\ndelete window.p // false\r\n```\r\n\r\n上面命令中，`p`是`var`命令聲明的變數，`delete`命令無法刪除它，返回`false`。因為`var`聲明的全域變數都是頂層物件的屬性，而且預設不得刪除。\r\n\r\n### in運算子\r\n\r\n`in`運算子用於檢查物件是否包含某個屬性（注意，檢查的是鍵名，不是鍵值），如果包含就返回`true`，否則返回`false`。\r\n\r\n```JavaScript\r\nvar o = { p: 1 };\r\n\'p\' in o // true\r\n\r\n```\r\n\r\n在JavaScript語言中，所有全域變數都是頂層物件（流覽器的頂層物件就是`window`物件）的屬性，因此可以用`in`運算子判斷，一個全域變數是否存在。\r\n\r\n```JavaScript\r\n// 假設變數x未定義\r\n\r\n// 寫法一：報錯\r\nif (x) { return 1; }\r\n\r\n// 寫法二：不正確\r\nif (window.x) { return 1; }\r\n\r\n// 寫法三：正確\r\nif (\'x\' in window) { return 1; }\r\n\r\n```\r\n\r\n上面三種寫法之中，如果`x`不存在，第一種寫法會報錯；如果`x`的值對應布林值`false`（比如`x`等於空字串），第二種寫法無法得到正確結果；只有第三種寫法，才能正確判斷變數`x`是否存在。\r\n\r\n`in`運算子的一個問題是，它不能識別物件繼承的屬性。\r\n\r\n```JavaScript\r\nvar o = new Object();\r\no.hasOwnProperty(\'toString\') // false\r\n\r\n\'toString\' in o // true\r\n\r\n```\r\n\r\n上面代碼中，`toString`方法不是物件`o`自身的屬性，而是繼承的屬性，`hasOwnProperty`方法可以說明這一點。但是，`in`運算子不能識別，對繼承的屬性也返回`true`。\r\n\r\n### for…in迴圈\r\n\r\n`for...in`迴圈用來遍歷一個物件的全部屬性。\r\n\r\n```JavaScript\r\nvar o = {a: 1, b: 2, c: 3};\r\n\r\nfor (var i in o) {\r\n  console.log(o[i]);\r\n}\r\n// 1\r\n// 2\r\n// 3\r\n\r\n```\r\n\r\n下面是一個使用`for...in`迴圈，提取物件屬性的例子。\r\n\r\n```JavaScript\r\nvar obj = {\r\n  x: 1,\r\n  y: 2\r\n};\r\nvar props = [];\r\nvar i = 0;\r\n\r\nfor (props[i++] in obj);\r\n\r\nprops // [\'x\', \'y\']\r\n\r\n```\r\n\r\n`for...in`迴圈有兩個使用注意點。\r\n\r\n-  它遍歷的是物件所有可遍歷（enumerable）的屬性，會跳過不可遍歷的屬性\r\n-  它不僅遍歷物件自身的屬性，還遍歷繼承的屬性。\r\n\r\n請看下面的例子。\r\n\r\n```JavaScript\r\n// name 是 Person 本身的屬性\r\nfunction Person(name) {\r\n  this.name = name;\r\n}\r\n\r\n// describe是Person.prototype的屬性\r\nPerson.prototype.describe = function () {\r\n  return \'Name: \'+this.name;\r\n};\r\n\r\nvar person = new Person(\'Jane\');\r\n\r\n// for...in迴圈會遍歷實例自身的屬性（name），\r\n// 以及繼承的屬性（describe）\r\nfor (var key in person) {\r\n  console.log(key);\r\n}\r\n// name\r\n// describe\r\n\r\n```\r\n\r\n上面代碼中，`name`是物件本身的屬性，`describe`是物件繼承的屬性，`for...in`迴圈的遍歷會包括這兩者。\r\n\r\n如果只想遍歷物件本身的屬性，可以使用`hasOwnProperty`方法，在迴圈內部判斷一下是不是自身的屬性。\r\n\r\n```JavaScript\r\nfor (var key in person) {\r\n  if (person.hasOwnProperty(key)) {\r\n    console.log(key);\r\n  }\r\n}\r\n// name\r\n\r\n```\r\n\r\n物件`person`其實還有其他繼承的屬性，比如`toString`。\r\n\r\n```JavaScript\r\nperson.toString()\r\n// \"[object Object]\"\r\n\r\n```\r\n\r\n這個`toString`屬性不會被`for...in`迴圈遍歷到，因為它默認設置為“不可遍歷”，詳見《標準庫》一章的`Object`物件部分。\r\n\r\n一般情況下，都是只想遍歷物件自身的屬性，所以不推薦使用`for...in`迴圈。\r\n\r\n## with語句\r\n\r\n`with`語句的格式如下：\r\n\r\n```JavaScript\r\nwith (object) {\r\n  statements;\r\n}\r\n\r\n```\r\n\r\n它的作用是操作同一個物件的多個屬性時，提供一些書寫的方便。\r\n\r\n```JavaScript\r\n// 例一\r\nwith (o) {\r\n  p1 = 1;\r\n  p2 = 2;\r\n}\r\n// 等同於\r\no.p1 = 1;\r\no.p2 = 2;\r\n\r\n// 例二\r\nwith (document.links[0]){\r\n  console.log(href);\r\n  console.log(title);\r\n  console.log(style);\r\n}\r\n// 等同於\r\nconsole.log(document.links[0].href);\r\nconsole.log(document.links[0].title);\r\nconsole.log(document.links[0].style);\r\n\r\n```\r\n\r\n注意，`with`區塊內部的變數，必須是當前物件已經存在的屬性，否則會創造一個當前作用域的全域變數。這是因為`with`區塊沒有改變作用域，它的內部依然是當前作用域。\r\n\r\n```JavaScript\r\nvar o = {};\r\n\r\nwith (o) {\r\n  x = \"abc\";\r\n}\r\n\r\no.x // undefined\r\nx // \"abc\"\r\n\r\n```\r\n\r\n上面代碼中，物件`o`沒有屬性`x`，所以`with`區塊內部對`x`的操作，等於創造了一個全域變數`x`。正確的寫法應該是，先定義物件`o`的屬性`x`，然後在`with`區塊內操作它。\r\n\r\n```JavaScript\r\nvar o = {};\r\no.x = 1;\r\n\r\nwith (o) {\r\n  x = 2;\r\n}\r\n\r\no.x // 2\r\n\r\n```\r\n\r\n這是`with`語句的一個很大的弊病，就是綁定物件不明確。\r\n\r\n```JavaScript\r\nwith (o) {\r\n  console.log(x);\r\n}\r\n\r\n```\r\n\r\n單純從上面的代碼塊，根本無法判斷`x`到底是全域變數，還是`o`物件的一個屬性。這非常不利於代碼的除錯和模組化，編譯器也無法對這段代碼進行優化，只能留到運行時判斷，這就拖慢了運行速度。因此，建議不要使用`with`語句，可以考慮用一個臨時變數代替`with`。\r\n\r\n```JavaScript\r\nwith(o1.o2.o3) {\r\n  console.log(p1 + p2);\r\n}\r\n\r\n// 可以寫成\r\n\r\nvar temp = o1.o2.o3;\r\nconsole.log(temp.p1 + temp.p2);\r\n\r\n```\r\n\r\n`with`語句少數有用場合之一，就是替換範本變數。\r\n\r\n```JavaScript\r\nvar str = \'Hello <%= name %>!\';\r\n\r\n```\r\n\r\n上面代碼是一個範本字串。假定有一個`parser`函數，可以將這個字串解析成下面的樣子。\r\n\r\n```JavaScript\r\nparser(str)\r\n// \'\"Hello \", name, \"!\"\'\r\n\r\n```\r\n\r\n那麼，就可以利用`with`語句，進行範本變數替換。\r\n\r\n```JavaScript\r\nvar str = \'Hello <%= name %>!\';\r\n\r\nvar o = {\r\n  name: \'Alice\'\r\n};\r\n\r\nfunction tmpl(str, obj) {\r\n  str = \'var p = [];\' +\r\n    \'with (obj) {p.push(\' + parser(str) + \')};\' +\r\n    \'return p;\'\r\n  var r = (new Function(\'obj\', str))(obj);\r\n  return r.join(\'\');\r\n}\r\n\r\ntmpl(str, o)\r\n// \"Hello Alice!\"\r\n\r\n```\r\n\r\n上面代碼的核心邏輯是下面的部分。\r\n\r\n```JavaScript\r\nvar o = {\r\n  name: \'Alice\'\r\n};\r\n\r\nvar p = [];\r\n\r\nwith (o) {\r\n  p.push(\'Hello \', name, \'!\');\r\n};\r\n\r\np.join(\'\') // \"Hello Alice!\"\r\n\r\n```\r\n\r\n上面代碼中，`with`區塊內部，範本變數`name`可以被物件`o`的屬性替換，而`p`依然是全域變數。這就是很多範本引擎的實現原理。\r\n\r\n',_binary '','2022-10-25 19:49:11','https://unsplash.it/800/600?9','轉載',_binary '',_binary '',_binary '','JavaScript：物件','2023-05-14 19:47:40',15,8,1,'JavaScript學習筆記：對象。物件（object）是JavaScript的核心概念，也是最重要的資料類型。JavaScript的所有資料都可以被視為物件。（轉自：阮一峰 JavaScript 標準參考教程）'),(17,_binary '','## 1、 註冊 Heroku 免費帳戶\r\n\r\n流覽器打開[Heroku官網](https://www.heroku.com)，註冊一個免費的用戶，在註冊時選擇 `java` 語言\r\n\r\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fktloyozovj31kw0w2grn.jpg)\r\n\r\n\r\n\r\n## 2、安裝 Heroku CLI\r\n\r\n可以從Heroku官網的Getting Started引導頁中下載，選擇適合的系統版本，安裝到本機電腦\r\n\r\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fktlw3ieo3j31kw0t0484.jpg)\r\n\r\n**3、登錄到 Heroku**\r\n\r\n打開命令列，切換到你要發佈到Heroku的project 目錄下，或者使用IDEA的Terminal直接切換到你的project目錄下：\r\n\r\n>  下面涉及到的所有命令都是在專案檔案目錄下執行的（我的專案目錄為 blog）\r\n\r\n```shell\r\n$ heroku login\r\nEnter your Heroku credentials.\r\nEmail: java@example.com\r\nPassword:\r\n```\r\n\r\n使用 heroku login 命令，輸入註冊email和密碼，登錄\r\n\r\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fktmbyl33rj31ho0ssaeg.jpg)\r\n\r\n## 4、創建 Heroku APP\r\n\r\n```shell\r\n$ heroku create\r\nCreating warm-eyrie-9006... done, stack is cedar-14\r\nhttp://warm-eyrie-9006.herokuapp.com/ | https://git.heroku.com/warm-eyrie-9006.git\r\nGit remote heroku added\r\n```\r\n\r\n該命令會自動在Heroku雲端創建項目，項目名稱隨機生成，當前生成項目 `warm-eyrie-9006`\r\n\r\n## 5、為本地專案創建 Git repository\r\n\r\n本地專案部署到Heroku之前，需要先把本地專案存儲到 Git 倉庫。這裡要求你本地已安裝並配置好 Git 工具 。執行以下命令：\r\n\r\n```shell\r\n$ git init\r\n$ git add .\r\n$ git commit -m \"first commit\"\r\n```\r\n\r\n>  以上命令在你專案目錄路徑下執行\r\n\r\n## 6、部署本地專案代碼到Heroku\r\n\r\n```shell\r\n$ git push heroku master\r\nInitializing repository, done.\r\nCounting objects: 110, done.\r\nDelta compression using up to 4 threads.\r\nCompressing objects: 100% (87/87), done.\r\nWriting objects: 100% (110/110), 212.71 KiB | 0 bytes/s, done.\r\nTotal 110 (delta 30), reused 0 (delta 0)\r\n\r\n-----> Java app detected\r\n-----> Installing OpenJDK 1.8... done\r\n-----> Installing Maven 3.3.3... done\r\n-----> Executing: mvn -B -DskipTests=true clean install\r\n       [INFO] Scanning for projects...\r\n...\r\n       [INFO] ------------------------------------------------------------------------\r\n       [INFO] BUILD SUCCESS\r\n       [INFO] ------------------------------------------------------------------------\r\n       [INFO] Total time: 11.417s\r\n       [INFO] Finished at: Thu Sep 11 17:16:38 UTC 2014\r\n       [INFO] Final Memory: 21M/649M\r\n       [INFO] ------------------------------------------------------------------------\r\n-----> Discovering process types\r\n       Procfile declares types -> web\r\n```\r\n\r\n## 7、Heroku 上添加 MySQL 資料庫\r\n\r\n>  參考：http://selimsalihovic.github.io/2016-02-07-using-mysql-on-heroku/\r\n\r\n到 Heroku 官網，用創建好的帳戶登錄進去。然後打開自己已創建的項目主頁\r\n\r\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fktmnma7c5j31kw0fjgp7.jpg)\r\n\r\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fktmqb2gw6j30zc0min0i.jpg)\r\n\r\n點擊，Configure Add - ons\r\n\r\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fktmv475utj31kw0mcq94.jpg)\r\n\r\n選擇ClearDB MySQL之後，如果新用戶的話，會提示你綁定信用卡資訊。綁定信用卡後，才可以使用。這個是免費的，不會扣費。\r\n\r\n你需要到使用者設置裡面，綁定資訊欄目，綁定你的信用卡資訊\r\n\r\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fktn1opl4qj31hw0o0431.jpg)\r\n\r\n綁定之後，選擇安裝 ClearDB MySQL 。\r\n\r\n使用 `heroku addons` 命令可以看到已安裝的資料庫。\r\n\r\n```shell\r\n$ heroku addons\r\nAdd-on                          Plan    Price  State  \r\n──────────────────────────────  ──────  ─────  ───────\r\ncleardb (cleardb-closed-91123)  ignite  free   created\r\n └─ as CLEARDB_DATABASE\r\nThe table above shows add-ons and the attachments to the current app (lirenmi) or other apps.\r\n```\r\n\r\n## 8、獲取資料庫連接資訊\r\n\r\n使用 `heroku config` 命令可以獲取 MySQL 資料庫的連接 **URL**\r\n\r\n```shell\r\n$ heroku config\r\n=== lirenmi Config Vars\r\nCLEARDB_DATABASE_URL: mysql://b7ce049873150c:bf8f5b9a@us-cdbr-iron-east-05.cleardb.net/heroku_ea61f7c1c8e72d6?reconnect=true\r\n```\r\n\r\n獲取MySQL資料庫的連接用戶名和密碼：\r\n\r\n從專案主頁，找到已安裝的 ClearDB MySQL資料庫\r\n\r\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fktndalp4oj31by0rsn1m.jpg)\r\n\r\n點擊進入資料庫資訊頁面。\r\n\r\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fku5ow6lrlj31kw0koaft.jpg)\r\n\r\n選擇 System Information  找到連接資料庫的用戶名和密碼\r\n\r\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fku5trtljhj31kw0oxwlb.jpg)\r\n\r\n## 9、本地連接資料庫，初始化資訊\r\n\r\n我使用了Navicat工具連接資料庫，這裡需要注意的是主機名稱或IP位址，選擇資料庫URL的一部分 `us-cdbr-iron-east-05.cleardb.net`\r\n\r\n```\r\nCLEARDB_DATABASE_URL: mysql://b7ce049873150c:bf8f5b9a@us-cdbr-iron-east-05.cleardb.net/heroku_ea61f7c1c8e72d6?reconnect=true\r\n```\r\n\r\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fktnor17bfj31kw141k2b.jpg)\r\n\r\n連接成功之後，可以創建資料庫和初始化使用者資訊。\r\n\r\n\r\n\r\n## 10、修改本地專案的資料庫連接配置\r\n\r\n修改本地專案的資料庫連接配置\r\n\r\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fktnxekbqgj31kw0kzgqm.jpg)\r\n\r\n\r\n\r\n## 11、增加`Procfile`設定檔\r\n\r\n在專案根目錄增加 Procfile 設定檔，配置內容如下：\r\n\r\n```\r\nweb java -Dserver.port=$PORT $JAVA_OPTS -jar target/blog-0.0.1-SNAPSHOT.jar\r\n```\r\n\r\n## 12、編譯和打包本地專案\r\n\r\n專案根目錄下執行：\r\n\r\n```shell\r\n$ mvn package -Dmaven.test.skip=true\r\n```\r\n\r\n獲取\r\n\r\n```shell\r\n$ mvn clean install\r\n```\r\n\r\n\r\n\r\n## 13、再發佈和提交到Heroku\r\n\r\n專案根目錄依次執行：\r\n\r\n```shell\r\n$ git init\r\n$ git add .\r\n$ git commit -m \"released commit\"\r\n$ git push heroku master\r\n```\r\n\r\n現在程式已經配屬到 Heroku 上了\r\n\r\n## 14、打開專案訪問主頁\r\n\r\n執行下面的命令，會在流覽器打開專案主頁，我的項目主頁位址為：https://lirenmi.herokuapp.com/\r\n\r\n```shell\r\n$ heroku open\r\n```\r\n\r\n## 15、跟蹤日誌\r\n\r\n可以在本地查看 Heroku 的運行日誌，執行以下命令：\r\n\r\n```shell\r\n$ heroku logs --tail\r\n```\r\n\r\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fktobkp9u3j31kw0ni12n.jpg)\r\n\r\n\r\n\r\n## 16、如果想更改Heroku上項目的名稱可以使用以下方法\r\n\r\n二.在終端iterm修改heroku app的名稱\r\n方法1:進入對應app的專案，修改app名稱\r\n1.打開終端，登錄heroku，切換到要修該的app下\r\n2.執行`heroku apps:rename xxx` (xxx是你的app的新名稱）\r\n3.更新remote，\r\n執行`git remote rm heroku`\r\n執行`heroku git:remote -a xxx`\r\n\r\n\r\n\r\n參考連結：\r\n\r\nhttps://devcenter.heroku.com/articles/getting-started-with-java#introduction\r\n\r\nhttp://selimsalihovic.github.io/2016-02-07-using-mysql-on-heroku/\r\n\r\nhttp://xyy601-blog.logdown.com/posts/1387963-the-basics-how-to-rename-your-heroku-app-name\r\n\r\nhttps://docs.spring.io/spring-boot/docs/1.5.8.RELEASE/reference/htmlsingle/#cloud-deployment-heroku\r\n\r\n參考項目：https://github.com/britter/spring-boot-heroku-demo\r\n',_binary '','2022-10-25 21:11:35','https://unsplash.it/800/600','原創',_binary '',_binary '',_binary '','Spring Boot專案部屬到Heroku（備忘錄）','2023-05-14 19:49:10',15,14,1,'把Spring Boot項目部署到Heroku上，折騰了一下，終於搞定，但是ClearDB MySQL出現中文亂碼，還未解決......'),(20,_binary '','```java\r\npublic static void main(String[] args){\r\n	System.out.println(\"Hello, World!!\")\r\n}\r\n\r\nThis is a important code.\r\n```',_binary '','2023-05-14 19:40:20','aa','',_binary '',_binary '',_binary '','Hello World','2023-05-14 19:40:20',2,8,1,'aaa');
/*!40000 ALTER TABLE `t_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_blog_tags`
--

DROP TABLE IF EXISTS `t_blog_tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog_tags` (
  `blogs_id` bigint NOT NULL,
  `tags_id` bigint NOT NULL,
  KEY `FK5feau0gb4lq47fdb03uboswm8` (`tags_id`),
  KEY `FKh4pacwjwofrugxa9hpwaxg6mr` (`blogs_id`),
  CONSTRAINT `FK5feau0gb4lq47fdb03uboswm8` FOREIGN KEY (`tags_id`) REFERENCES `t_tag` (`id`),
  CONSTRAINT `FKh4pacwjwofrugxa9hpwaxg6mr` FOREIGN KEY (`blogs_id`) REFERENCES `t_blog` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog_tags`
--

LOCK TABLES `t_blog_tags` WRITE;
/*!40000 ALTER TABLE `t_blog_tags` DISABLE KEYS */;
INSERT INTO `t_blog_tags` VALUES (6,3),(6,5),(6,6),(6,7),(20,2),(20,3),(11,8),(8,7),(12,11),(15,7),(7,7),(13,9),(14,8),(17,2),(9,7);
/*!40000 ALTER TABLE `t_blog_tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_comment`
--

DROP TABLE IF EXISTS `t_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_comment` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `blog_id` bigint DEFAULT NULL,
  `parent_comment_id` bigint DEFAULT NULL,
  `admin_comment` bit(1) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FKke3uogd04j4jx316m1p51e05u` (`blog_id`),
  KEY `FK4jj284r3pb7japogvo6h72q95` (`parent_comment_id`),
  CONSTRAINT `FK4jj284r3pb7japogvo6h72q95` FOREIGN KEY (`parent_comment_id`) REFERENCES `t_comment` (`id`),
  CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=40 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_comment`
--

LOCK TABLES `t_comment` WRITE;
/*!40000 ALTER TABLE `t_comment` DISABLE KEYS */;
INSERT INTO `t_comment` VALUES (8,'https://unsplash.it/100/100?image=1005','測試評論功能','2022-10-22 22:11:53','white@gmail.com','小白',6,NULL,_binary '\0'),(9,'https://unsplash.it/100/100?image=1006','這個是@小白的一個評論訊息','2022-10-22 22:12:46','red@gmail.com','小红',6,8,_binary '\0'),(14,'https://unsplash.it/100/100?image=1007','小藍提交新的評論信息','2022-10-23 11:31:26','blue@gmail.com','小蓝',6,NULL,_binary '\0'),(15,'https://unsplash.it/100/100?image=1010','小白再回復小红的評論信息','2022-10-23 12:03:42','white@gmail.com','小白',6,9,_binary '\0'),(16,'/images/avatar.png','新的評論','2022-10-23 12:04:13','yellow@gmail.com','小黄',6,NULL,_binary '\0'),(19,'/images/avatar.png','管理員的評論信息','2022-10-23 13:41:38','hsuweizte@gmail.com','徐瑋澤',6,NULL,_binary ''),(20,'/images/avatar.png','管理員的評論信息','2022-10-23 13:41:56','hsuweizte@gmail.com','徐瑋澤',6,16,_binary ''),(22,'/images/avatar.png','個人一點點感悟','2022-10-25 21:08:36','hsuweizte@gmail.com','徐瑋澤',13,NULL,_binary ''),(23,'/images/avatar.png','Spring Boot專案部屬到Heroku的步驟備忘錄','2022-10-25 21:24:45','hsuweizte@gmail.com','徐瑋澤',17,NULL,_binary ''),(24,'https://unsplash.it/100/100?image=1005','問下版大，ClearDB MySQL怎麼安装？','2022-10-25 21:25:35','white@gmail.com','小白',17,NULL,_binary '\0'),(25,'https://unsplash.it/100/100?image=1017','還沒搞定MySQL','2022-10-25 21:26:34','changi@gmail.com','小強',17,24,_binary '\0'),(26,'https://unsplash.it/100/100?image=1032','路過....','2022-10-25 21:27:09','loveyou@gmail.com','爱上你',17,NULL,_binary '\0'),(27,'/images/avatar.png','建議從Heroku主頁去安装','2022-10-25 21:28:00','hsuweizte@gmail.com','徐瑋澤',17,24,_binary ''),(31,'https://unsplash.it/100/100?image=1040','小A的評論','2023-04-19 22:43:48','xiaoa@gmail.com','A',15,NULL,_binary '\0'),(32,'https://unsplash.it/100/100?image=1042','小B回覆小A的内容。','2023-04-19 22:44:15','xiaob@gmail.com','B',15,NULL,_binary '\0'),(33,'https://unsplash.it/100/100?image=1040','小A回覆内容......','2023-04-19 22:45:13','aa@gmail.com','A',13,22,_binary '\0'),(34,'https://unsplash.it/100/100?image=1042','B回覆内容.......','2023-04-19 22:45:44','bb@gmail.com','B',13,22,_binary '\0'),(35,'https://unsplash.it/100/100?image=1043','小C回覆B的内容.....','2023-04-19 22:46:48','cc@gmail.com','C',13,34,_binary '\0'),(36,'https://unsplash.it/100/100?image=1040','A的評論内容....','2023-04-19 22:49:59','aa@gmail.com','A',9,NULL,_binary '\0'),(37,'https://unsplash.it/100/100?image=1042','B回覆A的内容...','2023-04-19 22:50:34','bb@gmail.com','B',9,36,_binary '\0'),(38,'https://unsplash.it/100/100?image=1043','C回覆B的内容......','2023-04-19 22:51:05','cc@gmail.com','C',9,37,_binary '\0'),(39,'https://unsplash.it/100/100?image=1042','B回覆C的内容.....','2023-04-19 22:51:52','bb@gmail.com','B',9,38,_binary '\0');
/*!40000 ALTER TABLE `t_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_tag`
--

DROP TABLE IF EXISTS `t_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_tag`
--

LOCK TABLES `t_tag` WRITE;
/*!40000 ALTER TABLE `t_tag` DISABLE KEYS */;
INSERT INTO `t_tag` VALUES (1,'webstorm'),(2,'Spring Boot'),(3,'React'),(5,'HTML'),(6,'CSS'),(7,'JavaScript'),(8,'軟體技巧'),(9,'方法論'),(10,'刻意練習'),(11,'財富自由'),(12,'用戶體驗'),(13,'Java');
/*!40000 ALTER TABLE `t_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_type`
--

DROP TABLE IF EXISTS `t_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_type` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_type`
--

LOCK TABLES `t_type` WRITE;
/*!40000 ALTER TABLE `t_type` DISABLE KEYS */;
INSERT INTO `t_type` VALUES (8,'學習日誌'),(9,'前端'),(10,'清單'),(11,'認知升級'),(12,'創業'),(13,'全端開發'),(14,'開發者手冊'),(15,'自由職業'),(16,'思考與感悟');
/*!40000 ALTER TABLE `t_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user`
--

DROP TABLE IF EXISTS `t_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  `type` int DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user`
--

LOCK TABLES `t_user` WRITE;
/*!40000 ALTER TABLE `t_user` DISABLE KEYS */;
INSERT INTO `t_user` VALUES (1,'/images/avatar.png','2023-05-12 12:36:04','hsuweizte@gmail.com','徐瑋澤','96e79218965eb72c92a549dd5a330112',1,'2023-05-13 12:36:23','admin');
/*!40000 ALTER TABLE `t_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-05-14 21:44:45
